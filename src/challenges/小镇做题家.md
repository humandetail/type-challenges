## Esay ç»„

æ²¡ä»€ä¹ˆé¢˜æ˜¯ä¸€ä¸ª any è§£å†³ä¸äº†çš„ï¼Œå¦‚æœæœ‰ï¼Œé‚£å°±å†åŠ ä¸Š `@ts-ignore`ã€‚

### Pick

> Implement the built-in `Pick<T, K>` generic without using it.
>
>  Constructs a type by picking the set of properties `K` from `T`

```typescript
type MyPick<T, K> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Expected1, MyPick<Todo, 'title'>>>,
  Expect<Equal<Expected2, MyPick<Todo, 'title' | 'completed'>>>,
  // @ts-expect-error
  MyPick<Todo, 'title' | 'completed' | 'invalid'>,
]

interface Todo {
  title: string
  description: string
  completed: boolean
}

interface Expected1 {
  title: string
}

interface Expected2 {
  title: string
  completed: boolean
}
```

æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ cases é‡Œé¢çš„ `//@ts-expect-error` çš„æ³¨é‡Šï¼Œå®ƒçš„æ„æ€æ˜¯ï¼ŒæœŸæœ›ä¸‹é¢é‚£ä¸€è¡Œä»£ç æ˜¯ä¼šæŠ¥é”™ï¼Œé‚£ä¹ˆè¦æ€ä¹ˆåšå‘¢ï¼ŸTypeScript ä¸­çš„æ³›å‹æ˜¯å¯ä»¥é™åˆ¶ç±»å‹çš„ï¼Œåªè¦ä¼ å…¥çš„ç±»å‹ä¸æŒ‡å®šçš„ç±»å‹ä¸ç¬¦åˆï¼Œé‚£ä¹ˆå°±ä¼šæŠ¥é”™ã€‚ä¾‹å¦‚ï¼š

```typescript
type MyPick<T, K extends number> = any

// @ts-expect-error
type A = MyPick<{}, ''>
```

å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬ç»™ K æŒ‡å®šäº†ç±»å‹ï¼Œå®ƒå¿…é¡»æ˜¯ä¸€ä¸ª number ç±»å‹ï¼Œè€Œæˆ‘ä»¬åœ¨ä½¿ç”¨æ—¶ï¼Œä¼ å…¥äº†ä¸€ä¸ª `''`ï¼Œå®ƒæ˜¯ä¸€ä¸ª string ç±»å‹ï¼Œæ‰€ä»¥å°±ä¼šæŠ¥é”™ã€‚

æˆ‘ä»¬å†å›åˆ°é¢˜é‡Œï¼Œå…¶ä»–ä¸¤ä¸ª case æ˜¯ä¼ å…¥çš„ç±»å‹æ˜¯åˆæ³•çš„ï¼Ÿä¸‰ä¸ª case é‡Œé¢ K çš„ç±»å‹å·®å¼‚åœ¨äº `'invalid'`ï¼Œè€Œ `'title'`ã€`'completed'` æ˜¯åˆæ³•çš„ï¼Œå®ƒä»¬ä¹‹é—´çš„å…±åŒç‚¹å°±æ˜¯ï¼Œ `'title'`ã€`'completed'`  éƒ½å±äº Todo é‡Œé¢çš„ keyï¼Œè€Œ `'invalid'` ä¸å±æ€§ Todo çš„ keyã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹ä»£ç è®©ç¬¬ä¸‰ä¸ª case é€šè¿‡ï¼š

```js
type MyPick<T, K extends keyof T> = any
```

è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å°±è§£å†³äº†ç¬¬ä¸‰ä¸ª case çš„é—®é¢˜ã€‚æ¥ä¸‹æ¥è§£å†³å…¶å®ƒä¸¤ä¸ª caseï¼Œå†…å»ºçš„ Pick æ˜¯ä»æ¥å£ä¸­æå–å‡ºæ¥æŒ‡å®šçš„é”®ä»¥åŠå¯¹åº”çš„ç±»å‹ç»„æˆçš„æ–°çš„ Interfaceã€‚

```typescript
type MyPick<T, K extends keyof T> = {}
```

é‚£ä¹ˆè¿™ä¸ª key è¦æ€ä¹ˆç¡®å®šå‘¢ï¼Ÿé¦–å…ˆï¼Œå®ƒä¸€å®šæ˜¯ T é‡Œé¢çš„å­˜åœ¨çš„ keyï¼š

```typescript
type MyPick<T, K extends keyof T> = {
  [P in keyof T]: T[P]
}
```

å…¶æ¬¡ï¼Œå®ƒè¿˜å¿…é¡»æ˜¯ K é‡Œé¢æŒ‡å®šçš„ keyï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ as å†è¿›ä¸€æ­¥é™åˆ¶å®ƒçš„å–å€¼èŒƒå›´ï¼š

```typescript
type MyPick<T, K extends keyof T> = {
  [P in keyof T as P extends K ? P : never]: T[P]
}
```

è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å°±å®Œå…¨è§£å†³äº†è¿™é“é¢˜ã€‚

### Readonly

> Implement the built-in `Readonly<T>` generic without using it.
>
> Constructs a type with all properties of T set to readonly, meaning the properties of the constructed type cannot be reassigned.

```typescript
type MyReadonly<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MyReadonly<Todo1>, Readonly<Todo1>>>,
]

interface Todo1 {
  title: string
  description: string
  completed: boolean
  meta: {
    author: string
  }
}
```

è¿™é¢˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡ `readonly` æ¥ä¿®é¥°æŒ‡å®šçš„é”®å³å¯ï¼š

```typescript
type MyReadonly<T> = {
  readonly [K in keyof T]: T[K]
}
```

### Tuple to Object

> Give an array, transform into an object type and the key/value must in the given array.

```typescript
type TupleToObject<T extends readonly any[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const
const tupleNumber = [1, 2, 3, 4] as const
const tupleMix = [1, '2', 3, '4'] as const

type cases = [
  Expect<Equal<TupleToObject<typeof tuple>, { tesla: 'tesla'; 'model 3': 'model 3'; 'model X': 'model X'; 'model Y': 'model Y' }>>,
  Expect<Equal<TupleToObject<typeof tupleNumber>, { 1: 1; 2: 2; 3: 3; 4: 4 }>>,
  Expect<Equal<TupleToObject<typeof tupleMix>, { 1: 1; '2': '2'; 3: 3; '4': '4' }>>,
]

// @ts-expect-error
type error = TupleToObject<[[1, 2], {}]>
```

åŒæ ·çš„ï¼Œæˆ‘ä»¬å…ˆè§£å†³ `// @ts-expect-error` è¿™ä¸ª caseï¼Œä»å…¶å®ƒ case å¯ä»¥çœ‹åˆ°ï¼Œæ³›å‹ T åº”è¯¥æ˜¯ä¸€ä¸ªç”± number æˆ– string ç»„æˆçš„æ•°ç»„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ç»™å®ƒåŠ ä¸Šè¿™ä¸ªé™åˆ¶å³å¯ï¼š

```typescript
type TupleToObject<T extends readonly (number|string)[]> = any
```

è§£å†³å®Œè¿™ä¸ªä¹‹åï¼Œæˆ‘ä»¬ç»§ç»­å¤„ç†å…¶å®ƒçš„ caseï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œä½¿ç”¨ `keyof { a: 1, b: 2 }` å¯ä»¥å¾—åˆ°ä¸€ä¸ªç”±å¯¹è±¡çš„ key ç»„æˆçš„è”åˆç±»å‹ï¼š`'a' | 'b'`ï¼ŒåŒæ ·çš„ï¼Œåœ¨æ•°ç»„ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `['a', 'b'][number]` å¾—åˆ°ä¸€ä¸ªç”±æ•°ç»„ä¸­æ¯ä¸€é¡¹ç»„æˆçš„è”åˆç±»å‹ï¼š`'a' | 'b'`ï¼Œæ‰€ä»¥è¿™é¢˜æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å’Œ Pick åŒæ ·çš„æ€æƒ³æ¥å®Œæˆï¼š

```typescript
type TupleToObject<T extends readonly (number|string)[]> = {
  [K in T[number]]: K
}
```

### First of Array

> Implement a generic `First<T>` that takes an Array `T` and returns it's first element's type.

```typescript
type First<T extends any[]> = any


/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<First<[3, 2, 1]>, 3>>,
  Expect<Equal<First<[() => 123, { a: string }]>, () => 123>>,
  Expect<Equal<First<[]>, never>>,
  Expect<Equal<First<[undefined]>, undefined>>,
]

type errors = [
  // @ts-expect-error
  First<'notArray'>,
  // @ts-expect-error
  First<{ 0: 'arrayLike' }>,
]
```

è¿™é¢˜çš„ errors case å¯ä»¥ä¸çœ‹äº†ï¼Œç»™å‡ºçš„åˆå§‹æ¨¡æ¿å°±å·²ç»åšäº†ç±»å‹é™åˆ¶ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥å¤„ç†å³å¯ï¼Œè¿™é¢˜ä¹Ÿéå¸¸ç®€å•ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨æ•°ç»„çš„ç´¢å¼•å–å€¼å³å¯ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„ä¸€ä¸‹ç©ºæ•°ç»„æœŸæœ›å¾—åˆ°çš„æ˜¯ neverï¼š

```typescript
type First<T extends any[]> = T extends []
  ? never
  : T[0]
```

### Length of Tuple

> For given a tuple, you need create a generic `Length`, pick the length of the tuple

```typescript
type Length<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const tesla = ['tesla', 'model 3', 'model X', 'model Y'] as const
const spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT'] as const

type cases = [
  Expect<Equal<Length<typeof tesla>, 4>>,
  Expect<Equal<Length<typeof spaceX>, 5>>,
  // @ts-expect-error
  Length<5>,
  // @ts-expect-error
  Length<'hello world'>,
]
```

Error case åªéœ€è¦é™åˆ¶ä¸ºæ•°ç»„å³å¯ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå®ƒçš„æµ‹è¯•ç”¨ä¾‹éƒ½æŠŠæ•°ç»„è½¬æˆäº†åªè¯»çš„ï¼š

```typescript
type Length<T extends readonly unknown[]> = any
```

ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ•°ç»„çš„ `length` å±æ€§æ¥å–å‡ºæ•°ç»„é•¿åº¦ï¼š

```typescript
type Length<T extends readonly unknown[]> = T['length']
```

### Exclude

> Implement the built-in Exclude<T, U>

```typescript
type MyExclude<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MyExclude<'a' | 'b' | 'c', 'a'>, 'b' | 'c'>>,
  Expect<Equal<MyExclude<'a' | 'b' | 'c', 'a' | 'b'>, 'c'>>,
  Expect<Equal<MyExclude<string | number | (() => void), Function>, string | number>>,
]
```

åœ¨è§£è¿™ä¸ªé¢˜ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€ä¸‹**åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ï¼ˆDistributive Conditional Typesï¼‰**ï¼Œè¿™å¯¹äºæˆ‘ä»¬ä¹‹åçš„è§£é¢˜ä¹Ÿéå¸¸é‡è¦ã€‚

#### åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹

å½“æ¡ä»¶ç±»å‹ä½œç”¨äºæ³›å‹ç±»å‹æ—¶ï¼Œå®ƒä»¬åœ¨ç»™å®šè”åˆç±»å‹æ—¶ä¼šå˜æˆå¯åˆ†é…çš„ã€‚ä¾‹å¦‚ï¼š

```typescript
type ToArray<Type> = Type extends any ? Type[] : never;
```

å¦‚æœæˆ‘ä»¬å°†è”åˆç±»å‹æ’å…¥ ToArrayï¼Œåˆ™æ¡ä»¶ç±»å‹å°†ä¼šåº”ç”¨äºè¯¥è”åˆç±»å‹çš„æ¯ä¸ªæˆå‘˜ï¼š

```typescript
type StrArrOrNumArr = ToArray<string | number>;
// string[] | number[]
```

è¿™é‡Œå‘ç”Ÿçš„æ˜¯ StrArrOrNumArr åˆ†å¸ƒåœ¨ï¼š`string | number`ï¼Œå¹¶å°†è”åˆçš„æ¯ä¸ªæˆå‘˜ç±»å‹æ˜ å°„åˆ°æœ‰æ•ˆçš„å†…å®¹ï¼š`ToArray<string> | ToArray<number>`ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šå¾—åˆ°ï¼š

```typescript
string[] | number[];
```

é€šå¸¸ï¼Œåˆ†é…æ€§æ˜¯æœŸæœ›çš„è¡Œä¸ºï¼Œ ä¸ºäº†é¿å…è¿™ç§è¡Œä¸ºï¼Œæ‚¨å¯ä»¥ç”¨æ–¹æ‹¬å·å°† extends å…³é”®å­—çš„æ¯ä¸€ä¾§æ‹¬èµ·æ¥ï¼š

```typescript
type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;
 
// 'StrArrOrNumArr' ä¸å†æ˜¯ä¸€ä¸ªè”åˆç±»å‹
type StrArrOrNumArr = ToArrayNonDist<string | number>;
```

#### è§£é¢˜

ç†è§£äº†ä»€ä¹ˆæ˜¯åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ä¹‹åï¼Œè¿™ä¸€é¢˜çš„è§£å†³æ–¹æ¡ˆä¹Ÿå°±éšä¹‹è€Œæ¥äº†ï¼š

```typescript
type MyExclude<T, U> = T extends U ? never : T
```

åªè¦ T ä¸­çš„ä»»æ„é¡¹åœ¨ U ä¸Šèƒ½æ‰¾åˆ°ï¼Œé‚£ä¹ˆå°±å°†å®ƒå¿½ç•¥ï¼Œå¦åˆ™å°±ä¿ç•™ã€‚

### Awaited

> If we have a type which is wrapped type like Promise. How we can get a type which is inside the wrapped type?

```typescript
type MyAwaited<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type X = Promise<string>
type Y = Promise<{ field: number }>
type Z = Promise<Promise<string | number>>
type Z1 = Promise<Promise<Promise<string | boolean>>>

type cases = [
  Expect<Equal<MyAwaited<X>, string>>,
  Expect<Equal<MyAwaited<Y>, { field: number }>>,
  Expect<Equal<MyAwaited<Z>, string | number>>,
  Expect<Equal<MyAwaited<Z1>, string | boolean>>,
]

// @ts-expect-error
type error = MyAwaited<number>
```

å¾ˆæ˜æ˜¾ï¼Œè¿™é‡Œçš„ T åº”è¯¥æ˜¯ä¸€ä¸ª Promise ç±»å‹ï¼š

```typescript
type MyAwaited<T extends Promise<any>> = any
```

è¿™é‡Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€ä¸‹ `infer` è¿™ä¸ªå…³é”®å­—çš„ä½œç”¨ï¼š[https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

```typescript
type MyAwaited<T extends Promise<any>> = T extends Promise<infer R>
  ? R
  : never
```

ä½¿ç”¨ infer æ¨æ–­å‡ºä¼ é€’ç»™ Promise çš„ç±»å‹ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è½»æ¾åœ°æŠŠ cases ä¸­çš„ç¬¬ä¸€ã€äºŒä¸¤ä¸ª case ç»™è§£å†³æ‰ã€‚è€Œåé¢ä¸¤ä¸ª case å‡ºç°äº†åµŒå¥— Promise çš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å†æ¬¡é€’å½’è°ƒç”¨ MyAwaited æ¥å¤„ç†ï¼š

```typescript
type MyAwaited<T extends Promise<any>> = T extends Promise<infer R>
  ? R extends Promise<any>
    ? MyAwaited<R>
    : R
  : never
```

å¦‚æ­¤ä¸€æ¥ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†æ‰€æœ‰çš„ casesã€‚

### If

> Implement the util type `If<C, T, F>` which accepts condition `C`, a truthy value `T`, and a falsy value `F`. `C` is expected to be either `true` or `false` while `T` and `F` can be any type.

```typescript
type If<C, T, F> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<If<true, 'a', 'b'>, 'a'>>,
  Expect<Equal<If<false, 'a', 2>, 2>>,
]

// @ts-expect-error
type error = If<null, 'a', 'b'>
```

è¿™é¢˜é‡Œé¢å¾ˆæ˜æ˜¾ï¼ŒC æ˜¯ä¸€ä¸ª boolean ç±»å‹ï¼Œå½“ C ä¸º true æ—¶ï¼Œè¿”å› Tï¼Œå¦åˆ™è¿”å› Fï¼š

```typescript
type If<C extends boolean, T, F> = C extends true
  ? T
  : F
```

### Concat

> Implement the JavaScript `Array.concat` function in the type system. A type takes the two arguments. The output should be a new array that includes inputs in ltr order

```typescript
type Concat<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Concat<[], []>, []>>,
  Expect<Equal<Concat<[], [1]>, [1]>>,
  Expect<Equal<Concat<[1, 2], [3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<Concat<['1', 2, '3'], [false, boolean, '4']>, ['1', 2, '3', false, boolean, '4']>>,
]
```

è¿™é‡Œå°±å’Œ JavaScript ä¸­çš„æ•°ç»„åˆå¹¶æ˜¯ä¸€æ ·çš„ï¼Œä¸è¿‡æˆ‘ä»¬è¿˜æ˜¯éœ€è¦ç»™ä¼ å…¥çš„ç±»å‹åšä¸€ä¸‹é™åˆ¶ï¼š

```typescript
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U]
```

### Includes

> Implement the JavaScript `Array.includes` function in the type system. A type takes the two arguments. The output should be a boolean `true` or `false`.

```typescript
type Includes<T extends readonly any[], U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Kars'>, true>>,
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'>, false>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 7>, true>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 4>, false>>,
  Expect<Equal<Includes<[1, 2, 3], 2>, true>>,
  Expect<Equal<Includes<[1, 2, 3], 1>, true>>,
  Expect<Equal<Includes<[{}], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[boolean, 2, 3, 5, 6, 7], false>, false>>,
  Expect<Equal<Includes<[true, 2, 3, 5, 6, 7], boolean>, false>>,
  Expect<Equal<Includes<[false, 2, 3, 5, 6, 7], false>, true>>,
  Expect<Equal<Includes<[{ a: 'A' }], { readonly a: 'A' }>, false>>,
  Expect<Equal<Includes<[{ readonly a: 'A' }], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[1], 1 | 2>, false>>,
  Expect<Equal<Includes<[1 | 2], 1>, false>>,
  Expect<Equal<Includes<[null], undefined>, false>>,
  Expect<Equal<Includes<[undefined], null>, false>>,
]
```

Includesï¼Œé¡¾åæ€ä¹‰ï¼Œå®ƒæ˜¯åˆ¤æ–­ä¼ è¿›æ¥çš„ T æ˜¯å¦å­˜åœ¨å’Œ U ç›¸ç­‰çš„é¡¹ï¼Œè¿™é‡Œæˆ‘ä»¬å¯ä»¥å€ŸåŠ©æµ‹è¯•å·¥å…·é‡Œé¢å¼•å…¥çš„ Equal æ¥å¯¹æ•°ç»„ä¸­çš„æ¯ä¸€é¡¹å’Œ U åšç›¸ç­‰åˆ¤æ–­ï¼š

```typescript
type Includes<T extends readonly any[], U> = T extends [infer F, ...infer R]
  ? Equal<U, F> extends true
    ? true
    : Includes<R, U>
  : false
```

é€šè¿‡ `T extends [infer F, ...infer R]` å¯ä»¥å°†æ•°ç»„çš„æ¯ä¸€é¡¹é€ä¸€å–å‡ºæ¥æ¯”å¯¹ï¼Œå¦‚æœä¸º false åˆ™é€’å½’è°ƒç”¨ Includesï¼ŒæŠŠæ•°ç»„å‰©ä½™çš„ R å’Œ U ä¼ è¿›å»å†æ¬¡æ¯”å¯¹ï¼Œç›´è‡³æ•°ç»„æ‰€æœ‰é¡¹éƒ½æ¯”å¯¹å®Œæ¯•ã€‚

### Push

> Implement the generic version of `Array.push`

```typescript
type Push<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Push<[], 1>, [1]>>,
  Expect<Equal<Push<[1, 2], '3'>, [1, 2, '3']>>,
  Expect<Equal<Push<['1', 2, '3'], boolean>, ['1', 2, '3', boolean]>>,
]
```

è¿™é¢˜å’Œæˆ‘ä»¬ä¹‹å‰å®ç°çš„ Concat ä¸€æ ·ï¼Œåªä¸è¿‡æ˜¯ U æ˜¯ä¸€ä¸ªä»»æ„çš„ç±»å‹ï¼š

```typescript
type Push<T extends unknown[], U> = [...T, U]
```

### Unshift

> Implement the type version of `Array.unshift`

```typescript
type Unshift<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Unshift<[], 1>, [1]>>,
  Expect<Equal<Unshift<[1, 2], 0>, [0, 1, 2]>>,
  Expect<Equal<Unshift<['1', 2, '3'], boolean>, [boolean, '1', 2, '3']>>,
]
```

å’Œ Push å®ç°ä¸€è‡´ï¼š

```typescript
type Unshift<T extends unknown[], U> = [U, ...T]
```

### Parameters

> Implement the built-in Parameters<T> generic without using it.

```typescript
type MyParameters<T extends (...args: any[]) => any> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const foo = (arg1: string, arg2: number): void => {}
const bar = (arg1: boolean, arg2: { a: 'A' }): void => {}
const baz = (): void => {}

type cases = [
  Expect<Equal<MyParameters<typeof foo>, [string, number]>>,
  Expect<Equal<MyParameters<typeof bar>, [boolean, { a: 'A' }]>>,
  Expect<Equal<MyParameters<typeof baz>, []>>,
]
```

è¿™é¢˜åˆ©ç”¨ infer å³å¯ï¼š

```typescript
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer R) => any
  ? R
  : never
```

## Medium ç»„

### Get Return Type

> Implement the built-in `ReturnType<T>` generic without using it.

```typescript
type MyReturnType<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<string, MyReturnType<() => string>>>,
  Expect<Equal<123, MyReturnType<() => 123>>>,
  Expect<Equal<ComplexObject, MyReturnType<() => ComplexObject>>>,
  Expect<Equal<Promise<boolean>, MyReturnType<() => Promise<boolean>>>>,
  Expect<Equal<() => 'foo', MyReturnType<() => () => 'foo'>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn1>>>,
]

type ComplexObject = {
  a: [12, 'foo']
  bar: 'hello'
  prev(): number
}

const fn = (v: boolean) => v ? 1 : 2
const fn1 = (v: boolean, w: any) => v ? 1 : 2
```

å•Šå“ˆï¼Œæˆ‘ä»¬åˆšå®Œæˆäº†å¯¹å‡½æ•°æ•°æ®çš„æå–ï¼Œå–è¿”å›å€¼çš„æ€è·¯ä¸ä¹‹ç±»ä¼¼ï¼š

```typescript
type MyReturnType<T> = T extends (...args: any[]) => infer R
  ? R
  : never
```

### Omit

> Implement the built-in `Omit<T, K>` generic without using it.

```typescript
type MyOmit<T, K> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Expected1, MyOmit<Todo, 'description'>>>,
  Expect<Equal<Expected2, MyOmit<Todo, 'description' | 'completed'>>>,
]

// @ts-expect-error
type error = MyOmit<Todo, 'description' | 'invalid'>

interface Todo {
  title: string
  description: string
  completed: boolean
}

interface Expected1 {
  title: string
  completed: boolean
}

interface Expected2 {
  title: string
}
```

Omit æ˜¯ä¸€ä¸ªå†…ç½®çš„å·¥å…·ç±»å‹ï¼Œå®ƒçš„å®˜æ–¹è§£é‡Šæ˜¯ï¼šé€šè¿‡ä» Type ä¸­é€‰æ‹©æ‰€æœ‰å±æ€§ç„¶ååˆ é™¤ Keysï¼ˆå­—ç¬¦ä¸²æˆ–å­—ç¬¦ä¸²ç»„æˆçš„è”åˆç±»å‹ï¼‰æ¥æ„é€ ä¸€ä¸ªç±»å‹ã€‚

æˆ‘ä»¬å…ˆçœ‹ `// @ts-expect-error`ï¼Œå¾ˆæ˜¾ç„¶ï¼ŒK å¿…é¡»æ˜¯ T é‡Œé¢çš„é”®æ‰ç¬¦åˆè¦æ±‚ï¼š

```typescript
type MyOmit<T, K extends keyof T> = any
```

æ ¹æ®æˆ‘ä»¬ä¹‹å‰è§£å†³ Pick çš„æ€è·¯è§£å†³å³å¯ï¼š

```typescript
type MyOmit<T, K extends keyof T> = {
  [P in keyof T as P extends K ? never: P]: T[P]
}
```

### Readonly

> Implement a generic `MyReadonly2<T, K>` which takes two type argument `T` and `K`.
>
> `K` specify the set of properties of `T` that should set to Readonly. When `K` is not provided, it should make all properties readonly just like the normal `Readonly<T>`.

```typescript
type MyReadonly2<T, K> = any

/* _____________ Test Cases _____________ */
import type { Alike, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Alike<MyReadonly2<Todo1>, Readonly<Todo1>>>,
  Expect<Alike<MyReadonly2<Todo1, 'title' | 'description'>, Expected>>,
  Expect<Alike<MyReadonly2<Todo2, 'title' | 'description'>, Expected>>,
]

// @ts-expect-error
type error = MyReadonly2<Todo1, 'title' | 'invalid'>

interface Todo1 {
  title: string
  description?: string
  completed: boolean
}

interface Todo2 {
  readonly title: string
  description?: string
  completed: boolean
}

interface Expected {
  readonly title: string
  readonly description?: string
  completed: boolean
}
```

è¿™é¢˜å’Œ Pick çš„è§£é¢˜æ€è·¯å·®ä¸å¤šï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯åŒºåˆ† readonly é¡¹å’Œæ™®é€šé¡¹ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨äº¤å‰ç±»å‹æ¥å®Œæˆè¿™ä¸¤ä¸ªéƒ¨åˆ†ï¼š

```typescript
type MyReadonly2<T, K extends keyof T = keyof T> = {
  readonly [P in keyof T as P extends K ? P : never]: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}
```

### Deep Readonly

> Implement a generic `DeepReadonly<T>` which make every parameter of an object - and its sub-objects recursively - readonly.
>
> You can assume that we are only dealing with Objects in this challenge. Arrays, Functions, Classes and so on do not need to be taken into consideration. However, you can still challenge yourself by covering as many different cases as possible.

```typescript
type DeepReadonly<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<DeepReadonly<X>, Expected>>,
]

type X = {
  a: () => 22
  b: string
  c: {
    d: boolean
    e: {
      g: {
        h: {
          i: true
          j: 'string'
        }
        k: 'hello'
      }
      l: [
        'hi',
        {
          m: ['hey']
        },
      ]
    }
  }
}

type Expected = {
  readonly a: () => 22
  readonly b: string
  readonly c: {
    readonly d: boolean
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true
          readonly j: 'string'
        }
        readonly k: 'hello'
      }
      readonly l: readonly [
        'hi',
        {
          readonly m: readonly ['hey']
        },
      ]
    }
  }
}
```

ä¸€çœ‹åˆ° Deepï¼Œæˆ‘ä»¬å°±çŸ¥é“åº”è¯¥ä½¿ç”¨é€’å½’äº†ï¼Œè¿™é‡Œé€’å½’çš„æ¡ä»¶æ˜¯ï¼šéå‡½æ•°ç±»å‹çš„å¯¹è±¡ç±»å‹ï¼š

```typescript
type IsObject<T> = T extends Record<string, any>
  ? T extends Function
    ? false
    : true
  : false

// æˆ–è€…
type IsObject<T> = T extends object
  ? T extends Function
    ? false
    : true
  : false
```

ç„¶åæˆ‘ä»¬å°±å¯ä»¥é€’å½’æ“ä½œäº†ï¼š

```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: IsObject<T[P]> extends true
    ? DeepReadonly<T[P]>
    : T[P]
}
```

### Tuple To Union

> Implement a generic `TupleToUnion<T>` which covers the values of a tuple to its values union.

```typescript
type TupleToUnion<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TupleToUnion<[123, '456', true]>, 123 | '456' | true>>,
  Expect<Equal<TupleToUnion<[123]>, 123>>,
]
```

è¿™ä¸ªæˆ‘ä»¬åœ¨è§£ Exclude æ—¶å°±äº†è§£äº†åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠ T é™åˆ¶ä¸º Array ç±»å‹ï¼Œé€šè¿‡ `T[number]` å³å¯è§£å†³ï¼š

```typescript
type TupleToUnion<T extends unknown[]> = T[number]
```

### ChainableOptions

> Chainable options are commonly used in Javascript. But when we switch to TypeScript, can you properly type it?
>
> In this challenge, you need to type an object or a class - whatever you like - to provide two function `option(key, value)` and `get()`. In `option`, you can extend the current config type by the given key and value. We should about to access the final result via `get`.

```typescript
type Chainable = {
  option(key: string, value: any): any
  get(): any
}


/* _____________ Test Cases _____________ */
import type { Alike, Expect } from '@type-challenges/utils'

declare const a: Chainable

const result1 = a
  .option('foo', 123)
  .option('bar', { value: 'Hello World' })
  .option('name', 'type-challenges')
  .get()

const result2 = a
  .option('name', 'another name')
  // @ts-expect-error
  .option('name', 'last name')
  .get()

const result3 = a
  .option('name', 'another name')
  .option('name', 123)
  .get()

type cases = [
  Expect<Alike<typeof result1, Expected1>>,
  Expect<Alike<typeof result2, Expected2>>,
  Expect<Alike<typeof result3, Expected3>>,
]

type Expected1 = {
  foo: number
  bar: {
    value: string
  }
  name: string
}

type Expected2 = {
  name: string
}

type Expected3 = {
  name: number
}
```

åœ¨è§£é¢˜ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹ JavaScript ä¸­çš„é“¾å¼è°ƒç”¨æ˜¯æ€ä¹ˆè®¾è®¡çš„ï¼š

```js
const a = {
  options (name, value) {
    this[name] = value
    return this
  },
  
  get (name) {
    return this[name]
  }
}

const b = a
	.options('foo', 'bar')
	.get('foo')

const c = a
	.options('foo', 'bar')
	.options('foo', 'baz')
	.get('foo')

console.log(b) // 'bar'
console.log(c) // 'baz'
```

èµ·åˆ°é“¾å¼è°ƒç”¨çš„å…³é”®æ˜¯åœ¨ `options()` ä¸­è¿”å›äº†å½“å‰å¯¹è±¡ `this`ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåœ°æ–¹æ¥ä¿å­˜ç»“æœï¼Œè¿™æ ·æˆ‘ä»¬æ‰èƒ½åœ¨ `get()` è¢«è°ƒç”¨æ—¶å–å¾—å¯¹åº”çš„ç»“æœï¼š

```typescript
type Chainable<R = {}> = {
  option(key: string, value: any): any
  get(): R
}
```

ç„¶åï¼Œå†è®© `options()` è¢«è°ƒç”¨æ—¶ï¼ŒæŠŠå¯¹åº”çš„ key å’Œ value å­˜å‚¨åˆ°ç»“æœ R ä¸­ï¼š

```typescript
type Chainable<R = {}> = {
  option<K extends string, V>(key: K, value: V): Chainable<{ [P in K]: V }>
  get(): R
}
```

å½“ç„¶ï¼Œæˆ‘ä»¬éœ€è¦ä¿è¯ç»“æœ R ä¸­ä¸å­˜åœ¨æœ¬æ¬¡ä¼ è¿›æ¥çš„ Kï¼Œè¿˜è®°å¾—æˆ‘ä»¬ä¹‹å‰å®ç°çš„ Omit å—ï¼Ÿé€šè¿‡ Omit åœ¨ç»“æœ R ä¸­æ’é™¤æ‰å¯èƒ½å­˜åœ¨çš„ K å³å¯ï¼š

```typescript
type Chainable<R = {}> = {
  option<K extends string, V>(key: K, value: V): Chainable<Omit<R, K> & { [P in K]: V }>
  get(): R
}
```

æœ€åï¼Œæˆ‘ä»¬éœ€è¦è§£å†³æ‰ `// @ts-expect-error` é‚£ä¸ª caseï¼Œå¯ä»¥çœ‹åˆ°ï¼Œä¸¤æ¬¡è°ƒç”¨ `options()` ä¼ å…¥äº†ç›¸åŒçš„ key å’Œç›¸åŒç±»å‹çš„ valueï¼Œå¹¶ä¸”è¯¥æ³¨é‡Šæ˜¯åœ¨ `options()` ä¸Šçš„ï¼Œæ‰€ä»¥è¦åœ¨ `options()` è¿™é‡Œæ¥å¤„ç†ï¼š

```typescript
type Chainable<R = {}> = {
  option<K extends string, V>(key: number, value: V): Chainable<Omit<R, K> & { [P in K]: V }>
  get(): R
}
```

å½“æˆ‘ä»¬å°è¯•æŠŠ key çš„ç±»å‹æ”¹ä¸ºä¸€ä¸ªé string ç±»å‹æ—¶å‘ç°ï¼Œ`// @ts-expect-error` è¿™æ¡æ³¨é‡Šå–å¾—äº†é¢„æƒ³ä¸­çš„æ•ˆæœï¼Œåé¢åªéœ€è¦ç¡®ä¿åœ¨ R ä¸­ä¸å­˜åœ¨ç›¸åŒçš„ key å’ŒåŒç±»å‹çš„ value è¿™ä¸€æ¡ä»¶å³å¯ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å†åŠ ä¸€ä¸ªç±»å‹ï¼Œç”¨äºæ£€æµ‹ï¼Œå¹¶è¿”å› key æœ€ç»ˆçš„ç±»å‹ï¼š

```typescript
type GetKeyType<T, K extends string, V> = K extends keyof T
  ? T[K] extends V
    ? [] // åªè¦ä¸æ˜¯ string ç±»å‹å³å¯
    : K
  : K
```

ç„¶åå†åœ¨æŠŠ GetKeyType èµ‹äºˆ key å³å¯ï¼š

```typescript
type GetKeyType<T, K extends string, V> = K extends keyof T
  ? T[K] extends V
    ? number // åªè¦ä¸æ˜¯ string ç±»å‹å³å¯
    : K
  : K

type Chainable<R = {}> = {
  option<K extends string, V>(key: GetKeyType<R, K, V>, value: V): Chainable<Omit<R, K> & { [P in K]: V }>
  get(): R
}
```

### Last of Array

> TypeScript 4.0 is recommended in this challenge
>
> Implement a generic `Last<T>` that takes an Array `T` and returns its last element.

```typescript
type Last<T extends any[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Last<[3, 2, 1]>, 1>>,
  Expect<Equal<Last<[() => 123, { a: string }]>, { a: string }>>,
]
```

è¿™é¢˜æ¯”è¾ƒç®€å•ï¼Œå°±ä¸ç»†è¯´äº†ï¼š

```typescript
type Last<T extends any[]> = T extends [...infer R, infer L]
  ? L
  : never
```

### Pop

> TypeScript 4.0 is recommended in this challenge
>
> Implement a generic `Pop<T>` that takes an Array `T` and returns an Array without it's last element.

```typescript
type Pop<T extends any[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Pop<[3, 2, 1]>, [3, 2]>>,
  Expect<Equal<Pop<['a', 'b', 'c', 'd']>, ['a', 'b', 'c']>>,
]
```

è¿™ä¸ªå’Œä¸Šé¢çš„ Last æ˜¯ä¸€æ ·çš„ï¼š

```typescript
type Pop<T extends any[]> = T extends [...infer R, infer L]
  ? R
  : never
```

### Promise.all

> Type the function `PromiseAll` that accepts an array of PromiseLike objects, the returning value should be `Promise<T>` where `T` is the resolved result array.

```typescript
declare function PromiseAll(values: any): any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const promiseAllTest1 = PromiseAll([1, 2, 3] as const)
const promiseAllTest2 = PromiseAll([1, 2, Promise.resolve(3)] as const)
const promiseAllTest3 = PromiseAll([1, 2, Promise.resolve(3)])

type cases = [
  Expect<Equal<typeof promiseAllTest1, Promise<[1, 2, 3]>>>,
  Expect<Equal<typeof promiseAllTest2, Promise<[1, 2, number]>>>,
  Expect<Equal<typeof promiseAllTest3, Promise<[number, number, number]>>>,
]
```

å¯ä»¥çœ‹åˆ°ï¼Œé¢˜ç›®ç»™å‡ºçš„åˆå§‹ä»£ç æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æŒ‰ç…§ case  çš„è¦æ±‚åŠ ä¸Šæ³›å‹å’Œå‚æ•°é™åˆ¶ï¼š

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): any
```

å®ƒçš„è¿”å›å€¼åº”è¯¥æ˜¯ä¸€ä¸ª `Promise<any []>` ç±»å‹ï¼š

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): Promise<unknown []>
```

ä¼—æ‰€å‘¨çŸ¥ï¼Œåœ¨ JavaScript ä¸­ Array ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™ä¸€ç‚¹åœ¨ TypeScript ä¸­ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼š

```typescript
type Arr1 = string[]
type Arr2 = {
  [K: number]: string
}

type E = Expect<Equal<true, Arr1 extends Arr2 ? true : false>>
```

æ‰€ä»¥ç¬¬ä¸€ä¸ª case å°±å¾ˆç®€å•äº†ï¼š

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): Promise<{
  [K in keyof T]: T[K]
}>
```

è€Œåœ¨ç¬¬äºŒã€ç¬¬ä¸‰ä¸ª case çš„å‚æ•°æ•°ç»„é‡Œé¢å­˜åœ¨ç€ Promiseï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å¯¹ T[K] ä½œè¿›ä¸€æ­¥çš„åˆ¤æ–­ï¼š

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): Promise<{
  [K in keyof T]: T[K] extends Promise<infer D>
    ? D
    : T[K]
}>
```

å¦‚æ­¤ä¸€æ¥ï¼Œæ‰€æœ‰çš„ cases å°±è§£å†³äº†ã€‚

### Type Lookup

> Sometimes, you may want to lookup for a type in a union to by their attributes. 
>
> In this challenge, we would like to get the corresponding type by searching for the common `type` field in the union `Cat | Dog`. In other words, we will expect to get `Dog` for `LookUp<Dog | Cat, 'dog'>` and `Cat` for `LookUp<Dog | Cat, 'cat'>` in the following example.

```typescript
type LookUp<U, T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type Animal = Cat | Dog

type cases = [
  Expect<Equal<LookUp<Animal, 'dog'>, Dog>>,
  Expect<Equal<LookUp<Animal, 'cat'>, Cat>>,
]
```

åŒæ ·ï¼Œæˆ‘ä»¬è¿˜æ˜¯æ ¹æ®éœ€æ±‚æŠŠç±»å‹é™åˆ¶ç»™åŠ ä¸Šï¼š

```typescript
type LookUp<U extends Animal, T extends U['type']> = any
```

ä»é¢˜ä¸­å¯çŸ¥ï¼Œæ— è®ºæ˜¯ Cat è¿˜æ˜¯ Dogï¼Œéƒ½æ˜¯ç»§æ‰¿äº `{ type: string }` è¿™ä¸ªæ¥å£çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„ä»£ç æ¥æµ‹è¯•ä¸€ä¸‹ï¼š

```typescript
interface Base {
  type: string
}

type A = Expect<Equal<Cat extends Base ? true : false, true>>
type B = Expect<Equal<Dog extends Base ? true : false, true>>
```

å¦‚æœæˆ‘ä»¬å†æŠŠ Base é‡Œé¢çš„ type ä½œä¸€ä¸‹é™åˆ¶ï¼Œé‚£ä¹ˆè¿™é¢˜å°±å¾ˆå®¹æ˜“è§£å¼€äº†ï¼š

```typescript
interface Base<T> {
  type: T
}

type A = Expect<Equal<Cat extends Base<'cat'> ? true : false, true>>
type B = Expect<Equal<Dog extends Base<'dog'> ? true : false, true>>
```

æ‰€ä»¥æœ€ç»ˆæˆ‘ä»¬å¯ä»¥å¾—å‡ºè¿™æ ·çš„ç­”æ¡ˆï¼š

```typescript
interface Base<T> {
  type: T
}

type LookUp<U extends Animal, T extends U['type']> = U extends Base<T>
  ? U
  : never
```

### TrimLeft

> Implement `TrimLeft<T>` which takes an exact string type and returns a new string with the whitespace beginning removed.

```typescript
type TrimLeft<S extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TrimLeft<'str'>, 'str'>>,
  Expect<Equal<TrimLeft<' str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str     '>, 'str     '>>,
  Expect<Equal<TrimLeft<'   \n\t foo bar '>, 'foo bar '>>,
  Expect<Equal<TrimLeft<''>, ''>>,
  Expect<Equal<TrimLeft<' \n\t'>, ''>>,
]
```

è¿™é¢˜è€ƒéªŒçš„æ˜¯å­—ç¬¦ä¸²æ“ä½œï¼Œå’Œæ•°ç»„ä¸­çš„ Shift å¾ˆç›¸ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ä»£ç ä»å­—ç¬¦ä¸²ä¸­å–å€¼ï¼š

```typescript
type A<S extends string> = S extends `${infer F}${infer R}`
  ? F
  : never

type B = Expect<Equal<A<'Hello'>, 'H'>>
```

é¢˜ç›®ä¸­çš„è¦æ±‚æ˜¯ï¼šåªè¦å‰é¢çš„å­—ç¬¦æ˜¯ `''`ã€`\n` æˆ–è€… `\t` éƒ½ä¸è¦ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥é€’å½’æ¥å®Œæˆï¼š

```typescript
type TrimLeft<S extends string> = S extends `${infer F}${infer R}`
  ? F extends IgnoreString
    ? TrimLeft<R>
    : S
  : ''
```

å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æŠŠåˆ¤æ–­æ”¾åœ¨ infer é‡Œé¢ï¼š

```typescript
type TrimLeft<S extends string> = S extends `${infer F extends IgnoreString}${infer R}`
  ? TrimLeft<R>
  : S
```

### Capitalize

> Implement `Capitalize<T>` which converts the first letter of a string to uppercase and leave the rest as-is.

```typescript
type MyCapitalize<S extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MyCapitalize<'foobar'>, 'Foobar'>>,
  Expect<Equal<MyCapitalize<'FOOBAR'>, 'FOOBAR'>>,
  Expect<Equal<MyCapitalize<'foo bar'>, 'Foo bar'>>,
  Expect<Equal<MyCapitalize<''>, ''>>,
  Expect<Equal<MyCapitalize<'a'>, 'A'>>,
  Expect<Equal<MyCapitalize<'b'>, 'B'>>,
  Expect<Equal<MyCapitalize<'c'>, 'C'>>,
  Expect<Equal<MyCapitalize<'d'>, 'D'>>,
  Expect<Equal<MyCapitalize<'e'>, 'E'>>,
  Expect<Equal<MyCapitalize<'f'>, 'F'>>,
  Expect<Equal<MyCapitalize<'g'>, 'G'>>,
  Expect<Equal<MyCapitalize<'h'>, 'H'>>,
  Expect<Equal<MyCapitalize<'i'>, 'I'>>,
  Expect<Equal<MyCapitalize<'j'>, 'J'>>,
  Expect<Equal<MyCapitalize<'k'>, 'K'>>,
  Expect<Equal<MyCapitalize<'l'>, 'L'>>,
  Expect<Equal<MyCapitalize<'m'>, 'M'>>,
  Expect<Equal<MyCapitalize<'n'>, 'N'>>,
  Expect<Equal<MyCapitalize<'o'>, 'O'>>,
  Expect<Equal<MyCapitalize<'p'>, 'P'>>,
  Expect<Equal<MyCapitalize<'q'>, 'Q'>>,
  Expect<Equal<MyCapitalize<'r'>, 'R'>>,
  Expect<Equal<MyCapitalize<'s'>, 'S'>>,
  Expect<Equal<MyCapitalize<'t'>, 'T'>>,
  Expect<Equal<MyCapitalize<'u'>, 'U'>>,
  Expect<Equal<MyCapitalize<'v'>, 'V'>>,
  Expect<Equal<MyCapitalize<'w'>, 'W'>>,
  Expect<Equal<MyCapitalize<'x'>, 'X'>>,
  Expect<Equal<MyCapitalize<'y'>, 'Y'>>,
  Expect<Equal<MyCapitalize<'z'>, 'Z'>>,
]
```

Cases æœ‰ç‚¹å¤šå•Šï¼Œä¸è¿‡è¿™é¢˜ä¹Ÿå¾ˆç®€å•ï¼Œå®ƒåªéœ€è¦æŠŠç¬¬ä¸€ä¸ªå­—æ¯è½¬æˆå¤§å†™å³å¯ï¼Œåœ¨ TypeScript ä¸­æœ‰ä¸ª Uppercase çš„å·¥å…·ç±»å¯ä»¥æŠŠå­—æ¯è½¬æˆå¤§å†™ï¼š

```typescript
type A = Expect<Equal<'A', Uppercase<'a'>>>
type B = Expect<Equal<'BC', Uppercase<'bc'>>>
```

æ‰€ä»¥ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠé¦–å­—æ¯æ‹¿å‡ºæ¥è½¬æˆå¤§å†™å³å¯ï¼š

```typescript
type MyCapitalize<S extends string> = S extends `${infer F}${infer R}`
  ? `${Uppercase<F>}${R}`
  : S
```

### Replace

> Implement `Replace<S, From, To>` which replace the string `From` with `To` once in the given string `S`

```typescript
type Replace<S extends string, From extends string, To extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Replace<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', 'foo'>, 'foofoobar'>>,
  Expect<Equal<Replace<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', ''>, 'foobar'>>,
  Expect<Equal<Replace<'foobarbar', 'bra', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'', '', ''>, ''>>,
]
```

è¿™é¢˜åŒæ ·æ˜¯å­—ç¬¦ä¸²æ“ä½œï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœ From ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œé‚£å°±åŸæ ·è¾“å‡º Sï¼š

```typescript
type Replace<
  S extends string,
  From extends string,
  To extends string
> = From extends ''
  ? S
  : S extends `${infer F}${From}${infer R}`
    ? `${F}${To}${R}`
    : S
```

### ReplaceAll

> Implement `ReplaceAll<S, From, To>` which replace the all the substring `From` with `To` in the given string `S`

```typescript
type ReplaceAll<S extends string, From extends string, To extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ReplaceAll<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobar', 'bag', 'foo'>, 'foobar'>>,
  Expect<Equal<ReplaceAll<'foobarbar', 'bar', 'foo'>, 'foofoofoo'>>,
  Expect<Equal<ReplaceAll<'t y p e s', ' ', ''>, 'types'>>,
  Expect<Equal<ReplaceAll<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<ReplaceAll<'barfoo', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>,
  Expect<Equal<ReplaceAll<'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>,
  Expect<Equal<ReplaceAll<'', '', ''>, ''>>,
]
```

æŒ‰ç…§ Replace çš„æ€è·¯é€’å½’å³å¯ï¼š

```typescript
type ReplaceAll<
  S extends string,
  From extends string,
  To extends string
> = From extends ''
  ? S
  : S extends `${infer F}${From}${infer R}`
    ? ReplaceAll<`${F}${To}${R}`, From, To>
    : S
```

ä¸€æ°”å‘µæˆï¼Œä¸æ„§æ˜¯ä½ ï¼Œä½†æ˜¯æˆ‘ä»¬ä¼šå‘ç°ï¼Œæœ‰ä¸¤ä¸ª cases å¹¶æ²¡æœ‰è¢«è§£å†³æ‰ï¼š

```typescript
Expect<Equal<ReplaceAll<'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>
Expect<Equal<ReplaceAll<'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>
```

æˆ‘ä»¬æ‹¿ `ReplaceAll<'foobarfoobar', 'ob', 'b'>` è¿™ä¸ªæ¥è¯´ï¼Œåœ¨ç¬¬ä¸€æ¬¡æ‰§è¡Œæ›¿æ¢æ—¶ï¼š

```typescript
F ä¸º 'fo'
From ä¸º 'ob'
R ä¸º 'arfoobar'
```

æ‰€ä»¥æˆ‘ä»¬åœ¨ç»™ç¬¬äºŒæ¬¡æ‰§è¡Œ ReplaceAll æ‹¼æ¥çš„æ˜¯ï¼š`${F}${To}${R}` å³ `fobarfoobar`ï¼Œæ­¤æ—¶ï¼š

```typescript
F ä¸º 'f'
From ä¸º 'ob'
R ä¸º 'arfoobar'
```

åœ¨ç¬¬ä¸‰æ¬¡æ‰§è¡Œ ReplaceAll æ‹¼æ¥çš„æ˜¯ï¼š`${F}${To}${R}` å³ `fbarfoobar`ã€‚

ç»è¿‡ä¸€æ¬¡åˆä¸€æ¬¡çš„é€’å½’ï¼Œæœ€ç»ˆå¾—åˆ°çš„æ˜¯ `fbarfbar`ã€‚è¿™æ˜¾ç„¶ä¸ç¬¦åˆè¦æ±‚ä¸­çš„ï¼š`fobarfobar`ã€‚ä¸ºä»€ä¹ˆä¼šå‡ºç°è¿™ä¸ªé—®é¢˜ï¼Ÿæ˜¯å› ä¸ºæˆ‘ä»¬æŠŠå·²ç»æ›¿æ¢è¿‡åçš„å­—ç¬¦å†æ¬¡æ”¾è¿›äº†ä¸‹ä¸€æ¬¡é€’å½’çš„å‚æ•° T ä¸­ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸åˆç†çš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠæ¯ä¸€æ¬¡æ›¿æ¢çš„ç»“æœç»™å­˜å‚¨èµ·æ¥ï¼Œå¢åŠ ä¸€ä¸ªæ³›å‹ Resultï¼Œå®ƒçš„åˆå§‹å€¼ä¸ºç©ºå­—ç¬¦ä¸²ï¼š

```typescript
type ReplaceAll<
  S extends string,
  From extends string,
  To extends string,
  Result extends string = ''
> = From extends ''
  ? S
  : S extends `${infer F}${From}${infer R}`
    ? ReplaceAll<`${F}${To}${R}`, From, To>
    : S
```

åœ¨æ¯ä¸€æ¬¡æ‰§è¡Œæ›¿æ¢æ—¶ï¼ŒæŠŠç»“æœæ”¶é›†èµ·æ¥ï¼Œåœ¨ä¸‹ä¸€æ¬¡é€’å½’ä¼ é€’ç»™ S çš„å€¼æ˜¯å‰©ä½™å­—ç¬¦ï¼Œæœ€åè¿”å› Result å’Œæœ€åä¸€æ¬¡é€’å½’ä¼ å…¥çš„ S æ‹¼æ¥èµ·æ¥çš„å­—ç¬¦ä¸²å³å¯ï¼š

```typescript
type ReplaceAll<
  S extends string,
  From extends string,
  To extends string,
  Result extends string = ''
> = From extends ''
  ? S
  : S extends `${infer F}${From}${infer R}`
    ? ReplaceAll<R, From, To, `${Result}${F}${To}`>
    : `${Result}${S}`
```

### Append Argument

> For given function type `Fn`, and any type `A` (any in this context means we don't restrict the type, and I don't have in mind any type ğŸ˜‰) create a generic type which will take `Fn` as the first argument, `A` as the second, and will produce function type `G` which will be the same as `Fn` but with appended argument `A` as a last one.

```typescript
type AppendArgument<Fn, A> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type Case1 = AppendArgument<(a: number, b: string) => number, boolean>
type Result1 = (a: number, b: string, x: boolean) => number

type Case2 = AppendArgument<() => void, undefined>
type Result2 = (x: undefined) => void

type cases = [
  Expect<Equal<Case1, Result1>>,
  Expect<Equal<Case2, Result2>>,
]
```

æˆ‘ä»¬çŸ¥é“å‡½æ•°çš„å‚æ•°å¯ä»¥ç”¨ `...` æ¥æ”¶é›†å‰©ä½™å‚æ•°ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè€Œåœ¨ TypeScript ä¸­ä¹Ÿæ˜¯å¦‚æ­¤ï¼š

```typescript
type GetArgs<Fn> = Fn extends (...args: infer Args) => any
  ? Args
  : never

type A = Expect<Equal<GetArgs<(a: number, b: string, c: boolean) => 1>, [number, string, boolean]>>
```

æ‰€ä»¥è¿™é¢˜å’Œ Push æ˜¯éå¸¸ç›¸ä¼¼äº†ï¼Œåªä¸è¿‡å®ƒæ“ä½œçš„åœ°æ–¹æ˜¯å‡½æ•°çš„å‚æ•°è€Œå·²ï¼š

```typescript
type AppendArgument<
  Fn,
  A
> = Fn extends (...args: infer Args) => infer R
  ? (...args: [...Args, A]) => R
  : never
```

### Permutation

> Implement permutation type that transforms union types into the array that includes permutations of unions.

```typescript
type Permutation<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Permutation<'A'>, ['A']>>,
  Expect<Equal<Permutation<'A' | 'B' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<'B' | 'A' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<boolean>, [false, true] | [true, false]>>,
  Expect<Equal<Permutation<never>, []>>,
]
```

å¾ˆå…¸å‹çš„åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä¸‹ä¸€æ¬¡é€’å½’æ—¶è¦æ’é™¤æ‰æœ¬æ¬¡çš„å€¼ï¼š

```typescript
type Permutation<T, A = T> = [T] extends [never]
  ? []
  : T extends A
    ? [T, ...Permutation<Exclude<A, T>>]
    : never
```

### Length of String

> Compute the length of a string literal, which behaves like `String#length`.

```typescript
type LengthOfString<S extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<LengthOfString<''>, 0>>,
  Expect<Equal<LengthOfString<'kumiko'>, 6>>,
  Expect<Equal<LengthOfString<'reina'>, 5>>,
  Expect<Equal<LengthOfString<'Sound! Euphonium'>, 16>>,
]
```

So easyï¼Œ`S['length']` æ”¶å·¥ï¼š

```typescript
type LengthOfString<S extends string> = S['length']
```

å¾ˆé—æ†¾ï¼Œå¹¶æ²¡æœ‰å–å¾—é¢„æƒ³ä¸­çš„æ•ˆæœï¼Œå­—ç¬¦ä¸²æ²¡æœ‰ lengthï¼Œé‚£åªèƒ½é‡‡å–è¿‚å›æˆ˜æœ¯ï¼Œæ—¢ç„¶å­—ç¬¦ä¸²æ²¡æœ‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä½¿ç”¨ Arrayï¼š

```typescript
type LengthOfString<S extends string, Arr extends number[] = []> = S extends `${infer F}${infer R}`
  ? LengthOfString<R, [...Arr, 0]>
  : Arr['length']
```

### Flatten

> In this challenge, you would need to write a type that takes an array and emitted the flatten array type.

```typescript
type Flatten = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Flatten<[]>, []>>,
  Expect<Equal<Flatten<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<Flatten<[1, [2]]>, [1, 2]>>,
  Expect<Equal<Flatten<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, 5]>>,
  Expect<Equal<Flatten<[{ foo: 'bar'; 2: 10 }, 'foobar']>, [{ foo: 'bar'; 2: 10 }, 'foobar']>>,
]
```

åŒæ ·æ˜¯é€’å½’å¤„ç†æ•°ç»„ä¸­çš„æ¯ä¸€é¡¹ï¼Œå¦‚æœè¿˜æ˜¯æ•°ç»„å°±ç»§ç»­é€’å½’ï¼š

```typescript
type Flatten<T extends unknown[], Result extends unknown[] = []> = T extends [infer F, ...infer R]
  ? F extends unknown[]
    ? Flatten<R, [...Result, ...Flatten<F>]>
    : Flatten<R, [...Result, F]>
  : Result
```

### Append to object

> Implement a type that adds a new field to the interface. The type takes the three arguments. The output should be an object with the new field.

```typescript
type AppendToObject<T, U, V> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type test1 = {
  key: 'cat'
  value: 'green'
}

type testExpect1 = {
  key: 'cat'
  value: 'green'
  home: boolean
}

type test2 = {
  key: 'dog' | undefined
  value: 'white'
  sun: true
}

type testExpect2 = {
  key: 'dog' | undefined
  value: 'white'
  sun: true
  home: 1
}

type test3 = {
  key: 'cow'
  value: 'yellow'
  sun: false
}

type testExpect3 = {
  key: 'cow'
  value: 'yellow'
  sun: false
  isMotherRussia: false | undefined
}

type cases = [
  Expect<Equal<AppendToObject<test1, 'home', boolean>, testExpect1>>,
  Expect<Equal<AppendToObject<test2, 'home', 1>, testExpect2>>,
  Expect<Equal<AppendToObject<test3, 'isMotherRussia', false | undefined>, testExpect3>>,
]
```

è¿™é¢˜æˆ‘ä»¬éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒU æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒå°†ä½œä¸ºè¿”å›ç±»å‹çš„é”®ã€‚

æˆ‘ä»¬çŸ¥é“ï¼Œkeyof ä¼šè¿”å›ä¸€ä¸ªç”±å¯¹è±¡çš„é”®ç»„æˆçš„è”åˆç±»å‹ï¼Œæ­¤æ—¶ï¼Œå†æŠŠ U ç»™åŠ åˆ°è¿™ä¸ªè”åˆç±»å‹ç»„æˆæ–°çš„å¯¹è±¡çš„é”®ï¼Œå³å¯è§£é¢˜ï¼š

```typescript
type AppendToObject<T, U extends string, V> = {
  [P in keyof T | U]: P extends keyof T ? T[P] : V
}
```

### Absolute

> Implement the `Absolute` type. A type that take string, number or bigint. The output should be a positive number string

```typescript
type Absolute<T extends number | string | bigint> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Absolute<0>, '0'>>,
  Expect<Equal<Absolute<-0>, '0'>>,
  Expect<Equal<Absolute<10>, '10'>>,
  Expect<Equal<Absolute<-5>, '5'>>,
  Expect<Equal<Absolute<'0'>, '0'>>,
  Expect<Equal<Absolute<'-0'>, '0'>>,
  Expect<Equal<Absolute<'10'>, '10'>>,
  Expect<Equal<Absolute<'-5'>, '5'>>,
  Expect<Equal<Absolute<-1_000_000n>, '1000000'>>,
  Expect<Equal<Absolute<9_999n>, '9999'>>,
]
```

åœ¨ JavaScript ä¸­å–ç»å¯¹å€¼æ—¶å¯ä»¥ä½¿ç”¨ `Math.abs()`ï¼Œä½†åœ¨ TypeScript ä¸­å°±å¾—éœ€è¦ä¸€äº›å…¶ä»–æ“ä½œäº†ï¼š

```typescript
type Absolute<T extends number | string | bigint> = `${T}` extends `-${infer R}`
  ? R
  : `${T}`
```

åŒæ ·æ˜¯å­—ç¬¦ä¸²æ“ä½œï¼ŒæŠŠ `-` å·ç§»é™¤å³å¯ã€‚

### String to Union

> Implement the String to Union type. Type take string argument. The output should be a union of input letters

```typescript
type StringToUnion<T extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<StringToUnion<''>, never>>,
  Expect<Equal<StringToUnion<'t'>, 't'>>,
  Expect<Equal<StringToUnion<'hello'>, 'h' | 'e' | 'l' | 'l' | 'o'>>,
  Expect<Equal<StringToUnion<'coronavirus'>, 'c' | 'o' | 'r' | 'o' | 'n' | 'a' | 'v' | 'i' | 'r' | 'u' | 's'>>,
]
```

å­—ç¬¦ä¸²é€’å½’å³å¯ï¼Œæä¾›ä¸€ä¸ª Result æ¥æ”¶é›†æ¯æ¬¡é€’å½’çš„ç»“æœï¼Œåˆå§‹å€¼ä¸º neverï¼š

```typescript
type StringToUnion<T extends string, Result = never> = T extends `${infer F}${infer R}`
  ? StringToUnion<R, Result | F>
  : Result
```

### Merge

> Merge two types into a new type. Keys of the second type overrides keys of the first type.

```typescript
type Merge<F, S> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type Foo = {
  a: number
  b: string
}
type Bar = {
  b: number
  c: boolean
}

type cases = [
  Expect<Equal<Merge<Foo, Bar>, {
    a: number
    b: number
    c: boolean
  }>>,
]
```

è¿™ä¸€é¢˜å’Œå‰é¢åšçš„ [Append to object](#Append to object) å¾ˆç›¸ä¼¼ï¼š

```typescript
type Merge<F, S> = {
  [P in keyof F | keyof S]: P extends keyof S ? S[P] : P extends keyof F ? F[P] : never
}
```

### KebabCase

> Replace the `camelCase` or `PascalCase` string with `kebab-case`.

```typescript
type KebabCase<S> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<KebabCase<'FooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'fooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'foo-bar'>, 'foo-bar'>>,
  Expect<Equal<KebabCase<'foo_bar'>, 'foo_bar'>>,
  Expect<Equal<KebabCase<'Foo-Bar'>, 'foo--bar'>>,
  Expect<Equal<KebabCase<'ABC'>, 'a-b-c'>>,
  Expect<Equal<KebabCase<'-'>, '-'>>,
  Expect<Equal<KebabCase<''>, ''>>,
  Expect<Equal<KebabCase<'ğŸ˜'>, 'ğŸ˜'>>,
]
```

åœ¨ TypeScript çš„å·¥å…·ç±»ä¸­ï¼Œæœ‰ä¸€ä¸ªå·¥å…·æ˜¯å¯ä»¥æŠŠé¦–å­—æ¯è½¬æˆå°å†™ï¼Œå®ƒå°±æ˜¯ `Uncapitalize`ï¼š

```typescript
type A = 'HELLO WORLD'
type E = Expect<Equal<Uncapitalize<A>, 'hELLO WORLD'>>
```

å› ä¸ºè¿™ä¸€é¢˜é‡Œé¢é¦–å­—æ¯æ˜¯å¤§å†™æ—¶ï¼Œåªéœ€è¦æŠŠå®ƒè½¬æˆå°å†™å³å¯ï¼Œè€Œä¸éœ€è¦å†åŠ ä¸Š `-`ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¯¹å‰©ä½™å­—ç¬¦è¿›è¡Œåˆ¤æ–­ï¼š

```typescript
type KebabCase<S> = S extends `${infer F}${infer R}`
  ? R extends Uncapitalize<R>
    ? `${Lowercase<F>}${KebabCase<R>}`
    : `${Lowercase<F>}-${KebabCase<R>}`
  : S
```

### Diff

> Get an `Object` that is the difference between `O` & `O1`

```typescript
type Diff<O, O1> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type Foo = {
  name: string
  age: string
}
type Bar = {
  name: string
  age: string
  gender: number
}
type Coo = {
  name: string
  gender: number
}

type cases = [
  Expect<Equal<Diff<Foo, Bar>, { gender: number }>>,
  Expect<Equal<Diff<Bar, Foo>, { gender: number }>>,
  Expect<Equal<Diff<Foo, Coo>, { age: string; gender: number }>>,
  Expect<Equal<Diff<Coo, Foo>, { age: string; gender: number }>>,
]
```

å–å·®é›†ï¼ŒåŸºæ“ï¼Œåªéœ€è¦å»é™¤äº¤é›†å³å¯ï¼š

```typescript
type Diff<O, O1> = {
  [P in Exclude<keyof O, keyof O1> | Exclude<keyof O1, keyof O>]: P extends keyof O
    ? O[P]
    : P extends keyof O1
      ? O1[P]
      : never
}
```

### AnyOf

> Implement Python liked `any` function in the type system. A type takes the Array and returns `true` if any element of the Array is true. If the Array is empty, return `false`.

```typescript
type AnyOf<T extends readonly any[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<AnyOf<[1, 'test', true, [1], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[1, '', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, 'test', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', true, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [1], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], {}]>, false>>,
  Expect<Equal<AnyOf<[]>, false>>,
]
```

åªè¦ä¼ å…¥çš„æ•°ç»„ä¸­æœ‰ä¸€é¡¹ä¸º trueï¼Œåˆ™ç»“æœä¸º trueã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦çŸ¥é“å“ªäº›å€¼æ˜¯ falsy å€¼ï¼Œä» cases ä¸­å¯ä»¥å¾—çŸ¥ï¼š

```typescript
type Falsy = 0 | '' | [] | false | Record<PropertyKey, never>
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç©ºå¯¹è±¡ç±»å‹å¾—é‡‡ç”¨ `Record<PropertyKey, never>` æ¥è¡¨ç¤ºã€‚å¦‚æ­¤ä¸€æ¥ï¼Œè§£é¢˜ä¹Ÿå˜å¾—éå¸¸ç®€å•äº†ï¼š

```typescript
type Falsy = 0 | '' | [] | false | Record<PropertyKey, never>

type AnyOf<T extends readonly any[]> = T[number] extends Falsy
  ? false
  : true
```

### IsNever

> Implement a type IsNever, which takes input type `T`.
>
> If the type of resolves to `never`, return `true`, otherwise `false`.

```typescript
type IsNever<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsNever<never>, true>>,
  Expect<Equal<IsNever<never | string>, false>>,
  Expect<Equal<IsNever<''>, false>>,
  Expect<Equal<IsNever<undefined>, false>>,
  Expect<Equal<IsNever<null>, false>>,
  Expect<Equal<IsNever<[]>, false>>,
  Expect<Equal<IsNever<{}>, false>>,
]
```

æˆ‘æ€»æ„Ÿè§‰è¿™é¢˜ä¸åº”è¯¥å‡ºç°åœ¨è¿™ä¸ªæ ç›®ï¼š

```typescript
type IsNever<T> = [T] extends [never] ? true : false
```



