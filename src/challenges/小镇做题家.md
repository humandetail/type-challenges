## Esay ç»„

æ²¡ä»€ä¹ˆé¢˜æ˜¯ä¸€ä¸ª any è§£å†³ä¸äº†çš„ï¼Œå¦‚æœæœ‰ï¼Œé‚£å°±å†åŠ ä¸Š `@ts-ignore`ã€‚

### Pick

> Implement the built-in `Pick<T, K>` generic without using it.
>
>  Constructs a type by picking the set of properties `K` from `T`

```typescript
type MyPick<T, K> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Expected1, MyPick<Todo, 'title'>>>,
  Expect<Equal<Expected2, MyPick<Todo, 'title' | 'completed'>>>,
  // @ts-expect-error
  MyPick<Todo, 'title' | 'completed' | 'invalid'>,
]

interface Todo {
  title: string
  description: string
  completed: boolean
}

interface Expected1 {
  title: string
}

interface Expected2 {
  title: string
  completed: boolean
}
```

æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ cases é‡Œé¢çš„ `//@ts-expect-error` çš„æ³¨é‡Šï¼Œå®ƒçš„æ„æ€æ˜¯ï¼ŒæœŸæœ›ä¸‹é¢é‚£ä¸€è¡Œä»£ç æ˜¯ä¼šæŠ¥é”™ï¼Œé‚£ä¹ˆè¦æ€ä¹ˆåšå‘¢ï¼ŸTypeScript ä¸­çš„æ³›å‹æ˜¯å¯ä»¥é™åˆ¶ç±»å‹çš„ï¼Œåªè¦ä¼ å…¥çš„ç±»å‹ä¸æŒ‡å®šçš„ç±»å‹ä¸ç¬¦åˆï¼Œé‚£ä¹ˆå°±ä¼šæŠ¥é”™ã€‚ä¾‹å¦‚ï¼š

```typescript
type MyPick<T, K extends number> = any

// @ts-expect-error
type A = MyPick<{}, ''>
```

å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬ç»™ K æŒ‡å®šäº†ç±»å‹ï¼Œå®ƒå¿…é¡»æ˜¯ä¸€ä¸ª number ç±»å‹ï¼Œè€Œæˆ‘ä»¬åœ¨ä½¿ç”¨æ—¶ï¼Œä¼ å…¥äº†ä¸€ä¸ª `''`ï¼Œå®ƒæ˜¯ä¸€ä¸ª string ç±»å‹ï¼Œæ‰€ä»¥å°±ä¼šæŠ¥é”™ã€‚

æˆ‘ä»¬å†å›åˆ°é¢˜é‡Œï¼Œå…¶ä»–ä¸¤ä¸ª case æ˜¯ä¼ å…¥çš„ç±»å‹æ˜¯åˆæ³•çš„ï¼Ÿä¸‰ä¸ª case é‡Œé¢ K çš„ç±»å‹å·®å¼‚åœ¨äº `'invalid'`ï¼Œè€Œ `'title'`ã€`'completed'` æ˜¯åˆæ³•çš„ï¼Œå®ƒä»¬ä¹‹é—´çš„å…±åŒç‚¹å°±æ˜¯ï¼Œ `'title'`ã€`'completed'`  éƒ½å±äº Todo é‡Œé¢çš„ keyï¼Œè€Œ `'invalid'` ä¸å±æ€§ Todo çš„ keyã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹ä»£ç è®©ç¬¬ä¸‰ä¸ª case é€šè¿‡ï¼š

```js
type MyPick<T, K extends keyof T> = any
```

è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å°±è§£å†³äº†ç¬¬ä¸‰ä¸ª case çš„é—®é¢˜ã€‚æ¥ä¸‹æ¥è§£å†³å…¶å®ƒä¸¤ä¸ª caseï¼Œå†…å»ºçš„ Pick æ˜¯ä»æ¥å£ä¸­æå–å‡ºæ¥æŒ‡å®šçš„é”®ä»¥åŠå¯¹åº”çš„ç±»å‹ç»„æˆçš„æ–°çš„ Interfaceã€‚

```typescript
type MyPick<T, K extends keyof T> = {}
```

é‚£ä¹ˆè¿™ä¸ª key è¦æ€ä¹ˆç¡®å®šå‘¢ï¼Ÿé¦–å…ˆï¼Œå®ƒä¸€å®šæ˜¯ T é‡Œé¢çš„å­˜åœ¨çš„ keyï¼š

```typescript
type MyPick<T, K extends keyof T> = {
  [P in keyof T]: T[P]
}
```

å…¶æ¬¡ï¼Œå®ƒè¿˜å¿…é¡»æ˜¯ K é‡Œé¢æŒ‡å®šçš„ keyï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ as å†è¿›ä¸€æ­¥é™åˆ¶å®ƒçš„å–å€¼èŒƒå›´ï¼š

```typescript
type MyPick<T, K extends keyof T> = {
  [P in keyof T as P extends K ? P : never]: T[P]
}
```

è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å°±å®Œå…¨è§£å†³äº†è¿™é“é¢˜ã€‚

### Readonly

> Implement the built-in `Readonly<T>` generic without using it.
>
> Constructs a type with all properties of T set to readonly, meaning the properties of the constructed type cannot be reassigned.

```typescript
type MyReadonly<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MyReadonly<Todo1>, Readonly<Todo1>>>,
]

interface Todo1 {
  title: string
  description: string
  completed: boolean
  meta: {
    author: string
  }
}
```

è¿™é¢˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡ `readonly` æ¥ä¿®é¥°æŒ‡å®šçš„é”®å³å¯ï¼š

```typescript
type MyReadonly<T> = {
  readonly [K in keyof T]: T[K]
}
```

### Tuple to Object

> Give an array, transform into an object type and the key/value must in the given array.

```typescript
type TupleToObject<T extends readonly any[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const
const tupleNumber = [1, 2, 3, 4] as const
const tupleMix = [1, '2', 3, '4'] as const

type cases = [
  Expect<Equal<TupleToObject<typeof tuple>, { tesla: 'tesla'; 'model 3': 'model 3'; 'model X': 'model X'; 'model Y': 'model Y' }>>,
  Expect<Equal<TupleToObject<typeof tupleNumber>, { 1: 1; 2: 2; 3: 3; 4: 4 }>>,
  Expect<Equal<TupleToObject<typeof tupleMix>, { 1: 1; '2': '2'; 3: 3; '4': '4' }>>,
]

// @ts-expect-error
type error = TupleToObject<[[1, 2], {}]>
```

åŒæ ·çš„ï¼Œæˆ‘ä»¬å…ˆè§£å†³ `// @ts-expect-error` è¿™ä¸ª caseï¼Œä»å…¶å®ƒ case å¯ä»¥çœ‹åˆ°ï¼Œæ³›å‹ T åº”è¯¥æ˜¯ä¸€ä¸ªç”± number æˆ– string ç»„æˆçš„æ•°ç»„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ç»™å®ƒåŠ ä¸Šè¿™ä¸ªé™åˆ¶å³å¯ï¼š

```typescript
type TupleToObject<T extends readonly (number|string)[]> = any
```

è§£å†³å®Œè¿™ä¸ªä¹‹åï¼Œæˆ‘ä»¬ç»§ç»­å¤„ç†å…¶å®ƒçš„ caseï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œä½¿ç”¨ `keyof { a: 1, b: 2 }` å¯ä»¥å¾—åˆ°ä¸€ä¸ªç”±å¯¹è±¡çš„ key ç»„æˆçš„è”åˆç±»å‹ï¼š`'a' | 'b'`ï¼ŒåŒæ ·çš„ï¼Œåœ¨æ•°ç»„ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `['a', 'b'][number]` å¾—åˆ°ä¸€ä¸ªç”±æ•°ç»„ä¸­æ¯ä¸€é¡¹ç»„æˆçš„è”åˆç±»å‹ï¼š`'a' | 'b'`ï¼Œæ‰€ä»¥è¿™é¢˜æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å’Œ Pick åŒæ ·çš„æ€æƒ³æ¥å®Œæˆï¼š

```typescript
type TupleToObject<T extends readonly (number|string)[]> = {
  [K in T[number]]: K
}
```

### First of Array

> Implement a generic `First<T>` that takes an Array `T` and returns it's first element's type.

```typescript
type First<T extends any[]> = any


/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<First<[3, 2, 1]>, 3>>,
  Expect<Equal<First<[() => 123, { a: string }]>, () => 123>>,
  Expect<Equal<First<[]>, never>>,
  Expect<Equal<First<[undefined]>, undefined>>,
]

type errors = [
  // @ts-expect-error
  First<'notArray'>,
  // @ts-expect-error
  First<{ 0: 'arrayLike' }>,
]
```

è¿™é¢˜çš„ errors case å¯ä»¥ä¸çœ‹äº†ï¼Œç»™å‡ºçš„åˆå§‹æ¨¡æ¿å°±å·²ç»åšäº†ç±»å‹é™åˆ¶ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥å¤„ç†å³å¯ï¼Œè¿™é¢˜ä¹Ÿéå¸¸ç®€å•ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨æ•°ç»„çš„ç´¢å¼•å–å€¼å³å¯ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„ä¸€ä¸‹ç©ºæ•°ç»„æœŸæœ›å¾—åˆ°çš„æ˜¯ neverï¼š

```typescript
type First<T extends any[]> = T extends []
  ? never
  : T[0]
```

### Length of Tuple

> For given a tuple, you need create a generic `Length`, pick the length of the tuple

```typescript
type Length<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const tesla = ['tesla', 'model 3', 'model X', 'model Y'] as const
const spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT'] as const

type cases = [
  Expect<Equal<Length<typeof tesla>, 4>>,
  Expect<Equal<Length<typeof spaceX>, 5>>,
  // @ts-expect-error
  Length<5>,
  // @ts-expect-error
  Length<'hello world'>,
]
```

Error case åªéœ€è¦é™åˆ¶ä¸ºæ•°ç»„å³å¯ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå®ƒçš„æµ‹è¯•ç”¨ä¾‹éƒ½æŠŠæ•°ç»„è½¬æˆäº†åªè¯»çš„ï¼š

```typescript
type Length<T extends readonly unknown[]> = any
```

ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ•°ç»„çš„ `length` å±æ€§æ¥å–å‡ºæ•°ç»„é•¿åº¦ï¼š

```typescript
type Length<T extends readonly unknown[]> = T['length']
```

### Exclude

> Implement the built-in Exclude<T, U>

```typescript
type MyExclude<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MyExclude<'a' | 'b' | 'c', 'a'>, 'b' | 'c'>>,
  Expect<Equal<MyExclude<'a' | 'b' | 'c', 'a' | 'b'>, 'c'>>,
  Expect<Equal<MyExclude<string | number | (() => void), Function>, string | number>>,
]
```

åœ¨è§£è¿™ä¸ªé¢˜ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€ä¸‹**åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ï¼ˆDistributive Conditional Typesï¼‰**ï¼Œè¿™å¯¹äºæˆ‘ä»¬ä¹‹åçš„è§£é¢˜ä¹Ÿéå¸¸é‡è¦ã€‚

#### åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹

å½“æ¡ä»¶ç±»å‹ä½œç”¨äºæ³›å‹ç±»å‹æ—¶ï¼Œå®ƒä»¬åœ¨ç»™å®šè”åˆç±»å‹æ—¶ä¼šå˜æˆå¯åˆ†é…çš„ã€‚ä¾‹å¦‚ï¼š

```typescript
type ToArray<Type> = Type extends any ? Type[] : never;
```

å¦‚æœæˆ‘ä»¬å°†è”åˆç±»å‹æ’å…¥ ToArrayï¼Œåˆ™æ¡ä»¶ç±»å‹å°†ä¼šåº”ç”¨äºè¯¥è”åˆç±»å‹çš„æ¯ä¸ªæˆå‘˜ï¼š

```typescript
type StrArrOrNumArr = ToArray<string | number>;
// string[] | number[]
```

è¿™é‡Œå‘ç”Ÿçš„æ˜¯ StrArrOrNumArr åˆ†å¸ƒåœ¨ï¼š`string | number`ï¼Œå¹¶å°†è”åˆçš„æ¯ä¸ªæˆå‘˜ç±»å‹æ˜ å°„åˆ°æœ‰æ•ˆçš„å†…å®¹ï¼š`ToArray<string> | ToArray<number>`ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šå¾—åˆ°ï¼š

```typescript
string[] | number[];
```

é€šå¸¸ï¼Œåˆ†é…æ€§æ˜¯æœŸæœ›çš„è¡Œä¸ºï¼Œ ä¸ºäº†é¿å…è¿™ç§è¡Œä¸ºï¼Œæ‚¨å¯ä»¥ç”¨æ–¹æ‹¬å·å°† extends å…³é”®å­—çš„æ¯ä¸€ä¾§æ‹¬èµ·æ¥ï¼š

```typescript
type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;
 
// 'StrArrOrNumArr' ä¸å†æ˜¯ä¸€ä¸ªè”åˆç±»å‹
type StrArrOrNumArr = ToArrayNonDist<string | number>;
```

#### è§£é¢˜

ç†è§£äº†ä»€ä¹ˆæ˜¯åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ä¹‹åï¼Œè¿™ä¸€é¢˜çš„è§£å†³æ–¹æ¡ˆä¹Ÿå°±éšä¹‹è€Œæ¥äº†ï¼š

```typescript
type MyExclude<T, U> = T extends U ? never : T
```

åªè¦ T ä¸­çš„ä»»æ„é¡¹åœ¨ U ä¸Šèƒ½æ‰¾åˆ°ï¼Œé‚£ä¹ˆå°±å°†å®ƒå¿½ç•¥ï¼Œå¦åˆ™å°±ä¿ç•™ã€‚

### Awaited

> If we have a type which is wrapped type like Promise. How we can get a type which is inside the wrapped type?

```typescript
type MyAwaited<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type X = Promise<string>
type Y = Promise<{ field: number }>
type Z = Promise<Promise<string | number>>
type Z1 = Promise<Promise<Promise<string | boolean>>>

type cases = [
  Expect<Equal<MyAwaited<X>, string>>,
  Expect<Equal<MyAwaited<Y>, { field: number }>>,
  Expect<Equal<MyAwaited<Z>, string | number>>,
  Expect<Equal<MyAwaited<Z1>, string | boolean>>,
]

// @ts-expect-error
type error = MyAwaited<number>
```

å¾ˆæ˜æ˜¾ï¼Œè¿™é‡Œçš„ T åº”è¯¥æ˜¯ä¸€ä¸ª Promise ç±»å‹ï¼š

```typescript
type MyAwaited<T extends Promise<any>> = any
```

è¿™é‡Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€ä¸‹ `infer` è¿™ä¸ªå…³é”®å­—çš„ä½œç”¨ï¼š[https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

```typescript
type MyAwaited<T extends Promise<any>> = T extends Promise<infer R>
  ? R
  : never
```

ä½¿ç”¨ infer æ¨æ–­å‡ºä¼ é€’ç»™ Promise çš„ç±»å‹ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è½»æ¾åœ°æŠŠ cases ä¸­çš„ç¬¬ä¸€ã€äºŒä¸¤ä¸ª case ç»™è§£å†³æ‰ã€‚è€Œåé¢ä¸¤ä¸ª case å‡ºç°äº†åµŒå¥— Promise çš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å†æ¬¡é€’å½’è°ƒç”¨ MyAwaited æ¥å¤„ç†ï¼š

```typescript
type MyAwaited<T extends Promise<any>> = T extends Promise<infer R>
  ? R extends Promise<any>
    ? MyAwaited<R>
    : R
  : never
```

å¦‚æ­¤ä¸€æ¥ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†æ‰€æœ‰çš„ casesã€‚

### If

> Implement the util type `If<C, T, F>` which accepts condition `C`, a truthy value `T`, and a falsy value `F`. `C` is expected to be either `true` or `false` while `T` and `F` can be any type.

```typescript
type If<C, T, F> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<If<true, 'a', 'b'>, 'a'>>,
  Expect<Equal<If<false, 'a', 2>, 2>>,
]

// @ts-expect-error
type error = If<null, 'a', 'b'>
```

è¿™é¢˜é‡Œé¢å¾ˆæ˜æ˜¾ï¼ŒC æ˜¯ä¸€ä¸ª boolean ç±»å‹ï¼Œå½“ C ä¸º true æ—¶ï¼Œè¿”å› Tï¼Œå¦åˆ™è¿”å› Fï¼š

```typescript
type If<C extends boolean, T, F> = C extends true
  ? T
  : F
```

### Concat

> Implement the JavaScript `Array.concat` function in the type system. A type takes the two arguments. The output should be a new array that includes inputs in ltr order

```typescript
type Concat<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Concat<[], []>, []>>,
  Expect<Equal<Concat<[], [1]>, [1]>>,
  Expect<Equal<Concat<[1, 2], [3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<Concat<['1', 2, '3'], [false, boolean, '4']>, ['1', 2, '3', false, boolean, '4']>>,
]
```

è¿™é‡Œå°±å’Œ JavaScript ä¸­çš„æ•°ç»„åˆå¹¶æ˜¯ä¸€æ ·çš„ï¼Œä¸è¿‡æˆ‘ä»¬è¿˜æ˜¯éœ€è¦ç»™ä¼ å…¥çš„ç±»å‹åšä¸€ä¸‹é™åˆ¶ï¼š

```typescript
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U]
```

### Includes

> Implement the JavaScript `Array.includes` function in the type system. A type takes the two arguments. The output should be a boolean `true` or `false`.

```typescript
type Includes<T extends readonly any[], U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Kars'>, true>>,
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'>, false>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 7>, true>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 4>, false>>,
  Expect<Equal<Includes<[1, 2, 3], 2>, true>>,
  Expect<Equal<Includes<[1, 2, 3], 1>, true>>,
  Expect<Equal<Includes<[{}], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[boolean, 2, 3, 5, 6, 7], false>, false>>,
  Expect<Equal<Includes<[true, 2, 3, 5, 6, 7], boolean>, false>>,
  Expect<Equal<Includes<[false, 2, 3, 5, 6, 7], false>, true>>,
  Expect<Equal<Includes<[{ a: 'A' }], { readonly a: 'A' }>, false>>,
  Expect<Equal<Includes<[{ readonly a: 'A' }], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[1], 1 | 2>, false>>,
  Expect<Equal<Includes<[1 | 2], 1>, false>>,
  Expect<Equal<Includes<[null], undefined>, false>>,
  Expect<Equal<Includes<[undefined], null>, false>>,
]
```

Includesï¼Œé¡¾åæ€ä¹‰ï¼Œå®ƒæ˜¯åˆ¤æ–­ä¼ è¿›æ¥çš„ T æ˜¯å¦å­˜åœ¨å’Œ U ç›¸ç­‰çš„é¡¹ï¼Œè¿™é‡Œæˆ‘ä»¬å¯ä»¥å€ŸåŠ©æµ‹è¯•å·¥å…·é‡Œé¢å¼•å…¥çš„ Equal æ¥å¯¹æ•°ç»„ä¸­çš„æ¯ä¸€é¡¹å’Œ U åšç›¸ç­‰åˆ¤æ–­ï¼š

```typescript
type Includes<T extends readonly any[], U> = T extends [infer F, ...infer R]
  ? Equal<U, F> extends true
    ? true
    : Includes<R, U>
  : false
```

é€šè¿‡ `T extends [infer F, ...infer R]` å¯ä»¥å°†æ•°ç»„çš„æ¯ä¸€é¡¹é€ä¸€å–å‡ºæ¥æ¯”å¯¹ï¼Œå¦‚æœä¸º false åˆ™é€’å½’è°ƒç”¨ Includesï¼ŒæŠŠæ•°ç»„å‰©ä½™çš„ R å’Œ U ä¼ è¿›å»å†æ¬¡æ¯”å¯¹ï¼Œç›´è‡³æ•°ç»„æ‰€æœ‰é¡¹éƒ½æ¯”å¯¹å®Œæ¯•ã€‚

### Push

> Implement the generic version of `Array.push`

```typescript
type Push<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Push<[], 1>, [1]>>,
  Expect<Equal<Push<[1, 2], '3'>, [1, 2, '3']>>,
  Expect<Equal<Push<['1', 2, '3'], boolean>, ['1', 2, '3', boolean]>>,
]
```

è¿™é¢˜å’Œæˆ‘ä»¬ä¹‹å‰å®ç°çš„ Concat ä¸€æ ·ï¼Œåªä¸è¿‡æ˜¯ U æ˜¯ä¸€ä¸ªä»»æ„çš„ç±»å‹ï¼š

```typescript
type Push<T extends unknown[], U> = [...T, U]
```

### Unshift

> Implement the type version of `Array.unshift`

```typescript
type Unshift<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Unshift<[], 1>, [1]>>,
  Expect<Equal<Unshift<[1, 2], 0>, [0, 1, 2]>>,
  Expect<Equal<Unshift<['1', 2, '3'], boolean>, [boolean, '1', 2, '3']>>,
]
```

å’Œ Push å®ç°ä¸€è‡´ï¼š

```typescript
type Unshift<T extends unknown[], U> = [U, ...T]
```

### Parameters

> Implement the built-in Parameters<T> generic without using it.

```typescript
type MyParameters<T extends (...args: any[]) => any> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const foo = (arg1: string, arg2: number): void => {}
const bar = (arg1: boolean, arg2: { a: 'A' }): void => {}
const baz = (): void => {}

type cases = [
  Expect<Equal<MyParameters<typeof foo>, [string, number]>>,
  Expect<Equal<MyParameters<typeof bar>, [boolean, { a: 'A' }]>>,
  Expect<Equal<MyParameters<typeof baz>, []>>,
]
```

è¿™é¢˜åˆ©ç”¨ infer å³å¯ï¼š

```typescript
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer R) => any
  ? R
  : never
```

## Medium ç»„

### Get Return Type

> Implement the built-in `ReturnType<T>` generic without using it.

```typescript
type MyReturnType<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<string, MyReturnType<() => string>>>,
  Expect<Equal<123, MyReturnType<() => 123>>>,
  Expect<Equal<ComplexObject, MyReturnType<() => ComplexObject>>>,
  Expect<Equal<Promise<boolean>, MyReturnType<() => Promise<boolean>>>>,
  Expect<Equal<() => 'foo', MyReturnType<() => () => 'foo'>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn1>>>,
]

type ComplexObject = {
  a: [12, 'foo']
  bar: 'hello'
  prev(): number
}

const fn = (v: boolean) => v ? 1 : 2
const fn1 = (v: boolean, w: any) => v ? 1 : 2
```

å•Šå“ˆï¼Œæˆ‘ä»¬åˆšå®Œæˆäº†å¯¹å‡½æ•°æ•°æ®çš„æå–ï¼Œå–è¿”å›å€¼çš„æ€è·¯ä¸ä¹‹ç±»ä¼¼ï¼š

```typescript
type MyReturnType<T> = T extends (...args: any[]) => infer R
  ? R
  : never
```

### Omit

> Implement the built-in `Omit<T, K>` generic without using it.

```typescript
type MyOmit<T, K> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Expected1, MyOmit<Todo, 'description'>>>,
  Expect<Equal<Expected2, MyOmit<Todo, 'description' | 'completed'>>>,
]

// @ts-expect-error
type error = MyOmit<Todo, 'description' | 'invalid'>

interface Todo {
  title: string
  description: string
  completed: boolean
}

interface Expected1 {
  title: string
  completed: boolean
}

interface Expected2 {
  title: string
}
```

Omit æ˜¯ä¸€ä¸ªå†…ç½®çš„å·¥å…·ç±»å‹ï¼Œå®ƒçš„å®˜æ–¹è§£é‡Šæ˜¯ï¼šé€šè¿‡ä» Type ä¸­é€‰æ‹©æ‰€æœ‰å±æ€§ç„¶ååˆ é™¤ Keysï¼ˆå­—ç¬¦ä¸²æˆ–å­—ç¬¦ä¸²ç»„æˆçš„è”åˆç±»å‹ï¼‰æ¥æ„é€ ä¸€ä¸ªç±»å‹ã€‚

æˆ‘ä»¬å…ˆçœ‹ `// @ts-expect-error`ï¼Œå¾ˆæ˜¾ç„¶ï¼ŒK å¿…é¡»æ˜¯ T é‡Œé¢çš„é”®æ‰ç¬¦åˆè¦æ±‚ï¼š

```typescript
type MyOmit<T, K extends keyof T> = any
```

æ ¹æ®æˆ‘ä»¬ä¹‹å‰è§£å†³ Pick çš„æ€è·¯è§£å†³å³å¯ï¼š

```typescript
type MyOmit<T, K extends keyof T> = {
  [P in keyof T as P extends K ? never: P]: T[P]
}
```

### Readonly

> Implement a generic `MyReadonly2<T, K>` which takes two type argument `T` and `K`.
>
> `K` specify the set of properties of `T` that should set to Readonly. When `K` is not provided, it should make all properties readonly just like the normal `Readonly<T>`.

```typescript
type MyReadonly2<T, K> = any

/* _____________ Test Cases _____________ */
import type { Alike, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Alike<MyReadonly2<Todo1>, Readonly<Todo1>>>,
  Expect<Alike<MyReadonly2<Todo1, 'title' | 'description'>, Expected>>,
  Expect<Alike<MyReadonly2<Todo2, 'title' | 'description'>, Expected>>,
]

// @ts-expect-error
type error = MyReadonly2<Todo1, 'title' | 'invalid'>

interface Todo1 {
  title: string
  description?: string
  completed: boolean
}

interface Todo2 {
  readonly title: string
  description?: string
  completed: boolean
}

interface Expected {
  readonly title: string
  readonly description?: string
  completed: boolean
}
```

è¿™é¢˜å’Œ Pick çš„è§£é¢˜æ€è·¯å·®ä¸å¤šï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯åŒºåˆ† readonly é¡¹å’Œæ™®é€šé¡¹ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨äº¤å‰ç±»å‹æ¥å®Œæˆè¿™ä¸¤ä¸ªéƒ¨åˆ†ï¼š

```typescript
type MyReadonly2<T, K extends keyof T = keyof T> = {
  readonly [P in keyof T as P extends K ? P : never]: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}
```

### Deep Readonly

> Implement a generic `DeepReadonly<T>` which make every parameter of an object - and its sub-objects recursively - readonly.
>
> You can assume that we are only dealing with Objects in this challenge. Arrays, Functions, Classes and so on do not need to be taken into consideration. However, you can still challenge yourself by covering as many different cases as possible.

```typescript
type DeepReadonly<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<DeepReadonly<X>, Expected>>,
]

type X = {
  a: () => 22
  b: string
  c: {
    d: boolean
    e: {
      g: {
        h: {
          i: true
          j: 'string'
        }
        k: 'hello'
      }
      l: [
        'hi',
        {
          m: ['hey']
        },
      ]
    }
  }
}

type Expected = {
  readonly a: () => 22
  readonly b: string
  readonly c: {
    readonly d: boolean
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true
          readonly j: 'string'
        }
        readonly k: 'hello'
      }
      readonly l: readonly [
        'hi',
        {
          readonly m: readonly ['hey']
        },
      ]
    }
  }
}
```

ä¸€çœ‹åˆ° Deepï¼Œæˆ‘ä»¬å°±çŸ¥é“åº”è¯¥ä½¿ç”¨é€’å½’äº†ï¼Œè¿™é‡Œé€’å½’çš„æ¡ä»¶æ˜¯ï¼šéå‡½æ•°ç±»å‹çš„å¯¹è±¡ç±»å‹ï¼š

```typescript
type IsObject<T> = T extends Record<string, any>
  ? T extends Function
    ? false
    : true
  : false

// æˆ–è€…
type IsObject<T> = T extends object
  ? T extends Function
    ? false
    : true
  : false
```

ç„¶åæˆ‘ä»¬å°±å¯ä»¥é€’å½’æ“ä½œäº†ï¼š

```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: IsObject<T[P]> extends true
    ? DeepReadonly<T[P]>
    : T[P]
}
```

### Tuple To Union

> Implement a generic `TupleToUnion<T>` which covers the values of a tuple to its values union.

```typescript
type TupleToUnion<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TupleToUnion<[123, '456', true]>, 123 | '456' | true>>,
  Expect<Equal<TupleToUnion<[123]>, 123>>,
]
```

è¿™ä¸ªæˆ‘ä»¬åœ¨è§£ Exclude æ—¶å°±äº†è§£äº†åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠ T é™åˆ¶ä¸º Array ç±»å‹ï¼Œé€šè¿‡ `T[number]` å³å¯è§£å†³ï¼š

```typescript
type TupleToUnion<T extends unknown[]> = T[number]
```

### ChainableOptions

> Chainable options are commonly used in Javascript. But when we switch to TypeScript, can you properly type it?
>
> In this challenge, you need to type an object or a class - whatever you like - to provide two function `option(key, value)` and `get()`. In `option`, you can extend the current config type by the given key and value. We should about to access the final result via `get`.

```typescript
type Chainable = {
  option(key: string, value: any): any
  get(): any
}


/* _____________ Test Cases _____________ */
import type { Alike, Expect } from '@type-challenges/utils'

declare const a: Chainable

const result1 = a
  .option('foo', 123)
  .option('bar', { value: 'Hello World' })
  .option('name', 'type-challenges')
  .get()

const result2 = a
  .option('name', 'another name')
  // @ts-expect-error
  .option('name', 'last name')
  .get()

const result3 = a
  .option('name', 'another name')
  .option('name', 123)
  .get()

type cases = [
  Expect<Alike<typeof result1, Expected1>>,
  Expect<Alike<typeof result2, Expected2>>,
  Expect<Alike<typeof result3, Expected3>>,
]

type Expected1 = {
  foo: number
  bar: {
    value: string
  }
  name: string
}

type Expected2 = {
  name: string
}

type Expected3 = {
  name: number
}
```

åœ¨è§£é¢˜ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹ JavaScript ä¸­çš„é“¾å¼è°ƒç”¨æ˜¯æ€ä¹ˆè®¾è®¡çš„ï¼š

```js
const a = {
  options (name, value) {
    this[name] = value
    return this
  },
  
  get (name) {
    return this[name]
  }
}

const b = a
	.options('foo', 'bar')
	.get('foo')

const c = a
	.options('foo', 'bar')
	.options('foo', 'baz')
	.get('foo')

console.log(b) // 'bar'
console.log(c) // 'baz'
```

èµ·åˆ°é“¾å¼è°ƒç”¨çš„å…³é”®æ˜¯åœ¨ `options()` ä¸­è¿”å›äº†å½“å‰å¯¹è±¡ `this`ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåœ°æ–¹æ¥ä¿å­˜ç»“æœï¼Œè¿™æ ·æˆ‘ä»¬æ‰èƒ½åœ¨ `get()` è¢«è°ƒç”¨æ—¶å–å¾—å¯¹åº”çš„ç»“æœï¼š

```typescript
type Chainable<R = {}> = {
  option(key: string, value: any): any
  get(): R
}
```

ç„¶åï¼Œå†è®© `options()` è¢«è°ƒç”¨æ—¶ï¼ŒæŠŠå¯¹åº”çš„ key å’Œ value å­˜å‚¨åˆ°ç»“æœ R ä¸­ï¼š

```typescript
type Chainable<R = {}> = {
  option<K extends string, V>(key: K, value: V): Chainable<{ [P in K]: V }>
  get(): R
}
```

å½“ç„¶ï¼Œæˆ‘ä»¬éœ€è¦ä¿è¯ç»“æœ R ä¸­ä¸å­˜åœ¨æœ¬æ¬¡ä¼ è¿›æ¥çš„ Kï¼Œè¿˜è®°å¾—æˆ‘ä»¬ä¹‹å‰å®ç°çš„ Omit å—ï¼Ÿé€šè¿‡ Omit åœ¨ç»“æœ R ä¸­æ’é™¤æ‰å¯èƒ½å­˜åœ¨çš„ K å³å¯ï¼š

```typescript
type Chainable<R = {}> = {
  option<K extends string, V>(key: K, value: V): Chainable<Omit<R, K> & { [P in K]: V }>
  get(): R
}
```

æœ€åï¼Œæˆ‘ä»¬éœ€è¦è§£å†³æ‰ `// @ts-expect-error` é‚£ä¸ª caseï¼Œå¯ä»¥çœ‹åˆ°ï¼Œä¸¤æ¬¡è°ƒç”¨ `options()` ä¼ å…¥äº†ç›¸åŒçš„ key å’Œç›¸åŒç±»å‹çš„ valueï¼Œå¹¶ä¸”è¯¥æ³¨é‡Šæ˜¯åœ¨ `options()` ä¸Šçš„ï¼Œæ‰€ä»¥è¦åœ¨ `options()` è¿™é‡Œæ¥å¤„ç†ï¼š

```typescript
type Chainable<R = {}> = {
  option<K extends string, V>(key: number, value: V): Chainable<Omit<R, K> & { [P in K]: V }>
  get(): R
}
```

å½“æˆ‘ä»¬å°è¯•æŠŠ key çš„ç±»å‹æ”¹ä¸ºä¸€ä¸ªé string ç±»å‹æ—¶å‘ç°ï¼Œ`// @ts-expect-error` è¿™æ¡æ³¨é‡Šå–å¾—äº†é¢„æƒ³ä¸­çš„æ•ˆæœï¼Œåé¢åªéœ€è¦ç¡®ä¿åœ¨ R ä¸­ä¸å­˜åœ¨ç›¸åŒçš„ key å’ŒåŒç±»å‹çš„ value è¿™ä¸€æ¡ä»¶å³å¯ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å†åŠ ä¸€ä¸ªç±»å‹ï¼Œç”¨äºæ£€æµ‹ï¼Œå¹¶è¿”å› key æœ€ç»ˆçš„ç±»å‹ï¼š

```typescript
type GetKeyType<T, K extends string, V> = K extends keyof T
  ? T[K] extends V
    ? [] // åªè¦ä¸æ˜¯ string ç±»å‹å³å¯
    : K
  : K
```

ç„¶åå†åœ¨æŠŠ GetKeyType èµ‹äºˆ key å³å¯ï¼š

```typescript
type GetKeyType<T, K extends string, V> = K extends keyof T
  ? T[K] extends V
    ? number // åªè¦ä¸æ˜¯ string ç±»å‹å³å¯
    : K
  : K

type Chainable<R = {}> = {
  option<K extends string, V>(key: GetKeyType<R, K, V>, value: V): Chainable<Omit<R, K> & { [P in K]: V }>
  get(): R
}
```

### Last of Array

> TypeScript 4.0 is recommended in this challenge
>
> Implement a generic `Last<T>` that takes an Array `T` and returns its last element.

```typescript
type Last<T extends any[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Last<[3, 2, 1]>, 1>>,
  Expect<Equal<Last<[() => 123, { a: string }]>, { a: string }>>,
]
```

è¿™é¢˜æ¯”è¾ƒç®€å•ï¼Œå°±ä¸ç»†è¯´äº†ï¼š

```typescript
type Last<T extends any[]> = T extends [...infer R, infer L]
  ? L
  : never
```

### Pop

> TypeScript 4.0 is recommended in this challenge
>
> Implement a generic `Pop<T>` that takes an Array `T` and returns an Array without it's last element.

```typescript
type Pop<T extends any[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Pop<[3, 2, 1]>, [3, 2]>>,
  Expect<Equal<Pop<['a', 'b', 'c', 'd']>, ['a', 'b', 'c']>>,
]
```

è¿™ä¸ªå’Œä¸Šé¢çš„ Last æ˜¯ä¸€æ ·çš„ï¼š

```typescript
type Pop<T extends any[]> = T extends [...infer R, infer L]
  ? R
  : never
```

### Promise.all

> Type the function `PromiseAll` that accepts an array of PromiseLike objects, the returning value should be `Promise<T>` where `T` is the resolved result array.

```typescript
declare function PromiseAll(values: any): any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const promiseAllTest1 = PromiseAll([1, 2, 3] as const)
const promiseAllTest2 = PromiseAll([1, 2, Promise.resolve(3)] as const)
const promiseAllTest3 = PromiseAll([1, 2, Promise.resolve(3)])

type cases = [
  Expect<Equal<typeof promiseAllTest1, Promise<[1, 2, 3]>>>,
  Expect<Equal<typeof promiseAllTest2, Promise<[1, 2, number]>>>,
  Expect<Equal<typeof promiseAllTest3, Promise<[number, number, number]>>>,
]
```

å¯ä»¥çœ‹åˆ°ï¼Œé¢˜ç›®ç»™å‡ºçš„åˆå§‹ä»£ç æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æŒ‰ç…§ case  çš„è¦æ±‚åŠ ä¸Šæ³›å‹å’Œå‚æ•°é™åˆ¶ï¼š

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): any
```

å®ƒçš„è¿”å›å€¼åº”è¯¥æ˜¯ä¸€ä¸ª `Promise<any []>` ç±»å‹ï¼š

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): Promise<unknown []>
```

ä¼—æ‰€å‘¨çŸ¥ï¼Œåœ¨ JavaScript ä¸­ Array ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™ä¸€ç‚¹åœ¨ TypeScript ä¸­ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼š

```typescript
type Arr1 = string[]
type Arr2 = {
  [K: number]: string
}

type E = Expect<Equal<true, Arr1 extends Arr2 ? true : false>>
```

æ‰€ä»¥ç¬¬ä¸€ä¸ª case å°±å¾ˆç®€å•äº†ï¼š

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): Promise<{
  [K in keyof T]: T[K]
}>
```

è€Œåœ¨ç¬¬äºŒã€ç¬¬ä¸‰ä¸ª case çš„å‚æ•°æ•°ç»„é‡Œé¢å­˜åœ¨ç€ Promiseï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å¯¹ T[K] ä½œè¿›ä¸€æ­¥çš„åˆ¤æ–­ï¼š

```typescript
declare function PromiseAll<T extends unknown[]>(values: readonly [...T]): Promise<{
  [K in keyof T]: T[K] extends Promise<infer D>
    ? D
    : T[K]
}>
```

å¦‚æ­¤ä¸€æ¥ï¼Œæ‰€æœ‰çš„ cases å°±è§£å†³äº†ã€‚

### Type Lookup

> Sometimes, you may want to lookup for a type in a union to by their attributes. 
>
> In this challenge, we would like to get the corresponding type by searching for the common `type` field in the union `Cat | Dog`. In other words, we will expect to get `Dog` for `LookUp<Dog | Cat, 'dog'>` and `Cat` for `LookUp<Dog | Cat, 'cat'>` in the following example.

```typescript
type LookUp<U, T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type Animal = Cat | Dog

type cases = [
  Expect<Equal<LookUp<Animal, 'dog'>, Dog>>,
  Expect<Equal<LookUp<Animal, 'cat'>, Cat>>,
]
```

åŒæ ·ï¼Œæˆ‘ä»¬è¿˜æ˜¯æ ¹æ®éœ€æ±‚æŠŠç±»å‹é™åˆ¶ç»™åŠ ä¸Šï¼š

```typescript
type LookUp<U extends Animal, T extends U['type']> = any
```

ä»é¢˜ä¸­å¯çŸ¥ï¼Œæ— è®ºæ˜¯ Cat è¿˜æ˜¯ Dogï¼Œéƒ½æ˜¯ç»§æ‰¿äº `{ type: string }` è¿™ä¸ªæ¥å£çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„ä»£ç æ¥æµ‹è¯•ä¸€ä¸‹ï¼š

```typescript
interface Base {
  type: string
}

type A = Expect<Equal<Cat extends Base ? true : false, true>>
type B = Expect<Equal<Dog extends Base ? true : false, true>>
```

å¦‚æœæˆ‘ä»¬å†æŠŠ Base é‡Œé¢çš„ type ä½œä¸€ä¸‹é™åˆ¶ï¼Œé‚£ä¹ˆè¿™é¢˜å°±å¾ˆå®¹æ˜“è§£å¼€äº†ï¼š

```typescript
interface Base<T> {
  type: T
}

type A = Expect<Equal<Cat extends Base<'cat'> ? true : false, true>>
type B = Expect<Equal<Dog extends Base<'dog'> ? true : false, true>>
```

æ‰€ä»¥æœ€ç»ˆæˆ‘ä»¬å¯ä»¥å¾—å‡ºè¿™æ ·çš„ç­”æ¡ˆï¼š

```typescript
interface Base<T> {
  type: T
}

type LookUp<U extends Animal, T extends U['type']> = U extends Base<T>
  ? U
  : never
```

### TrimLeft

> Implement `TrimLeft<T>` which takes an exact string type and returns a new string with the whitespace beginning removed.

```typescript
type TrimLeft<S extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TrimLeft<'str'>, 'str'>>,
  Expect<Equal<TrimLeft<' str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str     '>, 'str     '>>,
  Expect<Equal<TrimLeft<'   \n\t foo bar '>, 'foo bar '>>,
  Expect<Equal<TrimLeft<''>, ''>>,
  Expect<Equal<TrimLeft<' \n\t'>, ''>>,
]
```

è¿™é¢˜è€ƒéªŒçš„æ˜¯å­—ç¬¦ä¸²æ“ä½œï¼Œå’Œæ•°ç»„ä¸­çš„ Shift å¾ˆç›¸ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ä»£ç ä»å­—ç¬¦ä¸²ä¸­å–å€¼ï¼š

```typescript
type A<S extends string> = S extends `${infer F}${infer R}`
  ? F
  : never

type B = Expect<Equal<A<'Hello'>, 'H'>>
```

é¢˜ç›®ä¸­çš„è¦æ±‚æ˜¯ï¼šåªè¦å‰é¢çš„å­—ç¬¦æ˜¯ `''`ã€`\n` æˆ–è€… `\t` éƒ½ä¸è¦ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥é€’å½’æ¥å®Œæˆï¼š

```typescript
type TrimLeft<S extends string> = S extends `${infer F}${infer R}`
  ? F extends IgnoreString
    ? TrimLeft<R>
    : S
  : ''
```

å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æŠŠåˆ¤æ–­æ”¾åœ¨ infer é‡Œé¢ï¼š

```typescript
type TrimLeft<S extends string> = S extends `${infer F extends IgnoreString}${infer R}`
  ? TrimLeft<R>
  : S
```

### Capitalize

> Implement `Capitalize<T>` which converts the first letter of a string to uppercase and leave the rest as-is.

```typescript
type MyCapitalize<S extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MyCapitalize<'foobar'>, 'Foobar'>>,
  Expect<Equal<MyCapitalize<'FOOBAR'>, 'FOOBAR'>>,
  Expect<Equal<MyCapitalize<'foo bar'>, 'Foo bar'>>,
  Expect<Equal<MyCapitalize<''>, ''>>,
  Expect<Equal<MyCapitalize<'a'>, 'A'>>,
  Expect<Equal<MyCapitalize<'b'>, 'B'>>,
  Expect<Equal<MyCapitalize<'c'>, 'C'>>,
  Expect<Equal<MyCapitalize<'d'>, 'D'>>,
  Expect<Equal<MyCapitalize<'e'>, 'E'>>,
  Expect<Equal<MyCapitalize<'f'>, 'F'>>,
  Expect<Equal<MyCapitalize<'g'>, 'G'>>,
  Expect<Equal<MyCapitalize<'h'>, 'H'>>,
  Expect<Equal<MyCapitalize<'i'>, 'I'>>,
  Expect<Equal<MyCapitalize<'j'>, 'J'>>,
  Expect<Equal<MyCapitalize<'k'>, 'K'>>,
  Expect<Equal<MyCapitalize<'l'>, 'L'>>,
  Expect<Equal<MyCapitalize<'m'>, 'M'>>,
  Expect<Equal<MyCapitalize<'n'>, 'N'>>,
  Expect<Equal<MyCapitalize<'o'>, 'O'>>,
  Expect<Equal<MyCapitalize<'p'>, 'P'>>,
  Expect<Equal<MyCapitalize<'q'>, 'Q'>>,
  Expect<Equal<MyCapitalize<'r'>, 'R'>>,
  Expect<Equal<MyCapitalize<'s'>, 'S'>>,
  Expect<Equal<MyCapitalize<'t'>, 'T'>>,
  Expect<Equal<MyCapitalize<'u'>, 'U'>>,
  Expect<Equal<MyCapitalize<'v'>, 'V'>>,
  Expect<Equal<MyCapitalize<'w'>, 'W'>>,
  Expect<Equal<MyCapitalize<'x'>, 'X'>>,
  Expect<Equal<MyCapitalize<'y'>, 'Y'>>,
  Expect<Equal<MyCapitalize<'z'>, 'Z'>>,
]
```

Cases æœ‰ç‚¹å¤šå•Šï¼Œä¸è¿‡è¿™é¢˜ä¹Ÿå¾ˆç®€å•ï¼Œå®ƒåªéœ€è¦æŠŠç¬¬ä¸€ä¸ªå­—æ¯è½¬æˆå¤§å†™å³å¯ï¼Œåœ¨ TypeScript ä¸­æœ‰ä¸ª Uppercase çš„å·¥å…·ç±»å¯ä»¥æŠŠå­—æ¯è½¬æˆå¤§å†™ï¼š

```typescript
type A = Expect<Equal<'A', Uppercase<'a'>>>
type B = Expect<Equal<'BC', Uppercase<'bc'>>>
```

æ‰€ä»¥ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠé¦–å­—æ¯æ‹¿å‡ºæ¥è½¬æˆå¤§å†™å³å¯ï¼š

```typescript
type MyCapitalize<S extends string> = S extends `${infer F}${infer R}`
  ? `${Uppercase<F>}${R}`
  : S
```

### Replace

> Implement `Replace<S, From, To>` which replace the string `From` with `To` once in the given string `S`

```typescript
type Replace<S extends string, From extends string, To extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Replace<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', 'foo'>, 'foofoobar'>>,
  Expect<Equal<Replace<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', ''>, 'foobar'>>,
  Expect<Equal<Replace<'foobarbar', 'bra', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'', '', ''>, ''>>,
]
```

è¿™é¢˜åŒæ ·æ˜¯å­—ç¬¦ä¸²æ“ä½œï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœ From ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œé‚£å°±åŸæ ·è¾“å‡º Sï¼š

```typescript
type Replace<
  S extends string,
  From extends string,
  To extends string
> = From extends ''
  ? S
  : S extends `${infer F}${From}${infer R}`
    ? `${F}${To}${R}`
    : S
```

### ReplaceAll

> Implement `ReplaceAll<S, From, To>` which replace the all the substring `From` with `To` in the given string `S`

```typescript
type ReplaceAll<S extends string, From extends string, To extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ReplaceAll<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobar', 'bag', 'foo'>, 'foobar'>>,
  Expect<Equal<ReplaceAll<'foobarbar', 'bar', 'foo'>, 'foofoofoo'>>,
  Expect<Equal<ReplaceAll<'t y p e s', ' ', ''>, 'types'>>,
  Expect<Equal<ReplaceAll<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<ReplaceAll<'barfoo', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>,
  Expect<Equal<ReplaceAll<'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>,
  Expect<Equal<ReplaceAll<'', '', ''>, ''>>,
]
```

æŒ‰ç…§ Replace çš„æ€è·¯é€’å½’å³å¯ï¼š

```typescript
type ReplaceAll<
  S extends string,
  From extends string,
  To extends string
> = From extends ''
  ? S
  : S extends `${infer F}${From}${infer R}`
    ? ReplaceAll<`${F}${To}${R}`, From, To>
    : S
```

ä¸€æ°”å‘µæˆï¼Œä¸æ„§æ˜¯ä½ ï¼Œä½†æ˜¯æˆ‘ä»¬ä¼šå‘ç°ï¼Œæœ‰ä¸¤ä¸ª cases å¹¶æ²¡æœ‰è¢«è§£å†³æ‰ï¼š

```typescript
Expect<Equal<ReplaceAll<'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>
Expect<Equal<ReplaceAll<'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>
```

æˆ‘ä»¬æ‹¿ `ReplaceAll<'foobarfoobar', 'ob', 'b'>` è¿™ä¸ªæ¥è¯´ï¼Œåœ¨ç¬¬ä¸€æ¬¡æ‰§è¡Œæ›¿æ¢æ—¶ï¼š

```typescript
F ä¸º 'fo'
From ä¸º 'ob'
R ä¸º 'arfoobar'
```

æ‰€ä»¥æˆ‘ä»¬åœ¨ç»™ç¬¬äºŒæ¬¡æ‰§è¡Œ ReplaceAll æ‹¼æ¥çš„æ˜¯ï¼š`${F}${To}${R}` å³ `fobarfoobar`ï¼Œæ­¤æ—¶ï¼š

```typescript
F ä¸º 'f'
From ä¸º 'ob'
R ä¸º 'arfoobar'
```

åœ¨ç¬¬ä¸‰æ¬¡æ‰§è¡Œ ReplaceAll æ‹¼æ¥çš„æ˜¯ï¼š`${F}${To}${R}` å³ `fbarfoobar`ã€‚

ç»è¿‡ä¸€æ¬¡åˆä¸€æ¬¡çš„é€’å½’ï¼Œæœ€ç»ˆå¾—åˆ°çš„æ˜¯ `fbarfbar`ã€‚è¿™æ˜¾ç„¶ä¸ç¬¦åˆè¦æ±‚ä¸­çš„ï¼š`fobarfobar`ã€‚ä¸ºä»€ä¹ˆä¼šå‡ºç°è¿™ä¸ªé—®é¢˜ï¼Ÿæ˜¯å› ä¸ºæˆ‘ä»¬æŠŠå·²ç»æ›¿æ¢è¿‡åçš„å­—ç¬¦å†æ¬¡æ”¾è¿›äº†ä¸‹ä¸€æ¬¡é€’å½’çš„å‚æ•° T ä¸­ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸åˆç†çš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠæ¯ä¸€æ¬¡æ›¿æ¢çš„ç»“æœç»™å­˜å‚¨èµ·æ¥ï¼Œå¢åŠ ä¸€ä¸ªæ³›å‹ Resultï¼Œå®ƒçš„åˆå§‹å€¼ä¸ºç©ºå­—ç¬¦ä¸²ï¼š

```typescript
type ReplaceAll<
  S extends string,
  From extends string,
  To extends string,
  Result extends string = ''
> = From extends ''
  ? S
  : S extends `${infer F}${From}${infer R}`
    ? ReplaceAll<`${F}${To}${R}`, From, To>
    : S
```

åœ¨æ¯ä¸€æ¬¡æ‰§è¡Œæ›¿æ¢æ—¶ï¼ŒæŠŠç»“æœæ”¶é›†èµ·æ¥ï¼Œåœ¨ä¸‹ä¸€æ¬¡é€’å½’ä¼ é€’ç»™ S çš„å€¼æ˜¯å‰©ä½™å­—ç¬¦ï¼Œæœ€åè¿”å› Result å’Œæœ€åä¸€æ¬¡é€’å½’ä¼ å…¥çš„ S æ‹¼æ¥èµ·æ¥çš„å­—ç¬¦ä¸²å³å¯ï¼š

```typescript
type ReplaceAll<
  S extends string,
  From extends string,
  To extends string,
  Result extends string = ''
> = From extends ''
  ? S
  : S extends `${infer F}${From}${infer R}`
    ? ReplaceAll<R, From, To, `${Result}${F}${To}`>
    : `${Result}${S}`
```

### Append Argument

> For given function type `Fn`, and any type `A` (any in this context means we don't restrict the type, and I don't have in mind any type ğŸ˜‰) create a generic type which will take `Fn` as the first argument, `A` as the second, and will produce function type `G` which will be the same as `Fn` but with appended argument `A` as a last one.

```typescript
type AppendArgument<Fn, A> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type Case1 = AppendArgument<(a: number, b: string) => number, boolean>
type Result1 = (a: number, b: string, x: boolean) => number

type Case2 = AppendArgument<() => void, undefined>
type Result2 = (x: undefined) => void

type cases = [
  Expect<Equal<Case1, Result1>>,
  Expect<Equal<Case2, Result2>>,
]
```

æˆ‘ä»¬çŸ¥é“å‡½æ•°çš„å‚æ•°å¯ä»¥ç”¨ `...` æ¥æ”¶é›†å‰©ä½™å‚æ•°ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè€Œåœ¨ TypeScript ä¸­ä¹Ÿæ˜¯å¦‚æ­¤ï¼š

```typescript
type GetArgs<Fn> = Fn extends (...args: infer Args) => any
  ? Args
  : never

type A = Expect<Equal<GetArgs<(a: number, b: string, c: boolean) => 1>, [number, string, boolean]>>
```

æ‰€ä»¥è¿™é¢˜å’Œ Push æ˜¯éå¸¸ç›¸ä¼¼äº†ï¼Œåªä¸è¿‡å®ƒæ“ä½œçš„åœ°æ–¹æ˜¯å‡½æ•°çš„å‚æ•°è€Œå·²ï¼š

```typescript
type AppendArgument<
  Fn,
  A
> = Fn extends (...args: infer Args) => infer R
  ? (...args: [...Args, A]) => R
  : never
```

### Permutation

> Implement permutation type that transforms union types into the array that includes permutations of unions.

```typescript
type Permutation<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Permutation<'A'>, ['A']>>,
  Expect<Equal<Permutation<'A' | 'B' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<'B' | 'A' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<boolean>, [false, true] | [true, false]>>,
  Expect<Equal<Permutation<never>, []>>,
]
```

å¾ˆå…¸å‹çš„åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä¸‹ä¸€æ¬¡é€’å½’æ—¶è¦æ’é™¤æ‰æœ¬æ¬¡çš„å€¼ï¼š

```typescript
type Permutation<T, A = T> = [T] extends [never]
  ? []
  : T extends A
    ? [T, ...Permutation<Exclude<A, T>>]
    : never
```

### Length of String

> Compute the length of a string literal, which behaves like `String#length`.

```typescript
type LengthOfString<S extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<LengthOfString<''>, 0>>,
  Expect<Equal<LengthOfString<'kumiko'>, 6>>,
  Expect<Equal<LengthOfString<'reina'>, 5>>,
  Expect<Equal<LengthOfString<'Sound! Euphonium'>, 16>>,
]
```

So easyï¼Œ`S['length']` æ”¶å·¥ï¼š

```typescript
type LengthOfString<S extends string> = S['length']
```

å¾ˆé—æ†¾ï¼Œå¹¶æ²¡æœ‰å–å¾—é¢„æƒ³ä¸­çš„æ•ˆæœï¼Œå­—ç¬¦ä¸²æ²¡æœ‰ lengthï¼Œé‚£åªèƒ½é‡‡å–è¿‚å›æˆ˜æœ¯ï¼Œæ—¢ç„¶å­—ç¬¦ä¸²æ²¡æœ‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä½¿ç”¨ Arrayï¼š

```typescript
type LengthOfString<S extends string, Arr extends number[] = []> = S extends `${infer F}${infer R}`
  ? LengthOfString<R, [...Arr, 0]>
  : Arr['length']
```

### Flatten

> In this challenge, you would need to write a type that takes an array and emitted the flatten array type.

```typescript
type Flatten = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Flatten<[]>, []>>,
  Expect<Equal<Flatten<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<Flatten<[1, [2]]>, [1, 2]>>,
  Expect<Equal<Flatten<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, 5]>>,
  Expect<Equal<Flatten<[{ foo: 'bar'; 2: 10 }, 'foobar']>, [{ foo: 'bar'; 2: 10 }, 'foobar']>>,
]
```

åŒæ ·æ˜¯é€’å½’å¤„ç†æ•°ç»„ä¸­çš„æ¯ä¸€é¡¹ï¼Œå¦‚æœè¿˜æ˜¯æ•°ç»„å°±ç»§ç»­é€’å½’ï¼š

```typescript
type Flatten<T extends unknown[], Result extends unknown[] = []> = T extends [infer F, ...infer R]
  ? F extends unknown[]
    ? Flatten<R, [...Result, ...Flatten<F>]>
    : Flatten<R, [...Result, F]>
  : Result
```

### Append to object

> Implement a type that adds a new field to the interface. The type takes the three arguments. The output should be an object with the new field.

```typescript
type AppendToObject<T, U, V> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type test1 = {
  key: 'cat'
  value: 'green'
}

type testExpect1 = {
  key: 'cat'
  value: 'green'
  home: boolean
}

type test2 = {
  key: 'dog' | undefined
  value: 'white'
  sun: true
}

type testExpect2 = {
  key: 'dog' | undefined
  value: 'white'
  sun: true
  home: 1
}

type test3 = {
  key: 'cow'
  value: 'yellow'
  sun: false
}

type testExpect3 = {
  key: 'cow'
  value: 'yellow'
  sun: false
  isMotherRussia: false | undefined
}

type cases = [
  Expect<Equal<AppendToObject<test1, 'home', boolean>, testExpect1>>,
  Expect<Equal<AppendToObject<test2, 'home', 1>, testExpect2>>,
  Expect<Equal<AppendToObject<test3, 'isMotherRussia', false | undefined>, testExpect3>>,
]
```

è¿™é¢˜æˆ‘ä»¬éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒU æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒå°†ä½œä¸ºè¿”å›ç±»å‹çš„é”®ã€‚

æˆ‘ä»¬çŸ¥é“ï¼Œkeyof ä¼šè¿”å›ä¸€ä¸ªç”±å¯¹è±¡çš„é”®ç»„æˆçš„è”åˆç±»å‹ï¼Œæ­¤æ—¶ï¼Œå†æŠŠ U ç»™åŠ åˆ°è¿™ä¸ªè”åˆç±»å‹ç»„æˆæ–°çš„å¯¹è±¡çš„é”®ï¼Œå³å¯è§£é¢˜ï¼š

```typescript
type AppendToObject<T, U extends string, V> = {
  [P in keyof T | U]: P extends keyof T ? T[P] : V
}
```

### Absolute

> Implement the `Absolute` type. A type that take string, number or bigint. The output should be a positive number string

```typescript
type Absolute<T extends number | string | bigint> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Absolute<0>, '0'>>,
  Expect<Equal<Absolute<-0>, '0'>>,
  Expect<Equal<Absolute<10>, '10'>>,
  Expect<Equal<Absolute<-5>, '5'>>,
  Expect<Equal<Absolute<'0'>, '0'>>,
  Expect<Equal<Absolute<'-0'>, '0'>>,
  Expect<Equal<Absolute<'10'>, '10'>>,
  Expect<Equal<Absolute<'-5'>, '5'>>,
  Expect<Equal<Absolute<-1_000_000n>, '1000000'>>,
  Expect<Equal<Absolute<9_999n>, '9999'>>,
]
```

åœ¨ JavaScript ä¸­å–ç»å¯¹å€¼æ—¶å¯ä»¥ä½¿ç”¨ `Math.abs()`ï¼Œä½†åœ¨ TypeScript ä¸­å°±å¾—éœ€è¦ä¸€äº›å…¶ä»–æ“ä½œäº†ï¼š

```typescript
type Absolute<T extends number | string | bigint> = `${T}` extends `-${infer R}`
  ? R
  : `${T}`
```

åŒæ ·æ˜¯å­—ç¬¦ä¸²æ“ä½œï¼ŒæŠŠ `-` å·ç§»é™¤å³å¯ã€‚

### String to Union

> Implement the String to Union type. Type take string argument. The output should be a union of input letters

```typescript
type StringToUnion<T extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<StringToUnion<''>, never>>,
  Expect<Equal<StringToUnion<'t'>, 't'>>,
  Expect<Equal<StringToUnion<'hello'>, 'h' | 'e' | 'l' | 'l' | 'o'>>,
  Expect<Equal<StringToUnion<'coronavirus'>, 'c' | 'o' | 'r' | 'o' | 'n' | 'a' | 'v' | 'i' | 'r' | 'u' | 's'>>,
]
```

å­—ç¬¦ä¸²é€’å½’å³å¯ï¼Œæä¾›ä¸€ä¸ª Result æ¥æ”¶é›†æ¯æ¬¡é€’å½’çš„ç»“æœï¼Œåˆå§‹å€¼ä¸º neverï¼š

```typescript
type StringToUnion<T extends string, Result = never> = T extends `${infer F}${infer R}`
  ? StringToUnion<R, Result | F>
  : Result
```

### Merge

> Merge two types into a new type. Keys of the second type overrides keys of the first type.

```typescript
type Merge<F, S> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type Foo = {
  a: number
  b: string
}
type Bar = {
  b: number
  c: boolean
}

type cases = [
  Expect<Equal<Merge<Foo, Bar>, {
    a: number
    b: number
    c: boolean
  }>>,
]
```

è¿™ä¸€é¢˜å’Œå‰é¢åšçš„ [Append to object](#Append to object) å¾ˆç›¸ä¼¼ï¼š

```typescript
type Merge<F, S> = {
  [P in keyof F | keyof S]: P extends keyof S ? S[P] : P extends keyof F ? F[P] : never
}
```

### KebabCase

> Replace the `camelCase` or `PascalCase` string with `kebab-case`.

```typescript
type KebabCase<S> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<KebabCase<'FooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'fooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'foo-bar'>, 'foo-bar'>>,
  Expect<Equal<KebabCase<'foo_bar'>, 'foo_bar'>>,
  Expect<Equal<KebabCase<'Foo-Bar'>, 'foo--bar'>>,
  Expect<Equal<KebabCase<'ABC'>, 'a-b-c'>>,
  Expect<Equal<KebabCase<'-'>, '-'>>,
  Expect<Equal<KebabCase<''>, ''>>,
  Expect<Equal<KebabCase<'ğŸ˜'>, 'ğŸ˜'>>,
]
```

åœ¨ TypeScript çš„å·¥å…·ç±»ä¸­ï¼Œæœ‰ä¸€ä¸ªå·¥å…·æ˜¯å¯ä»¥æŠŠé¦–å­—æ¯è½¬æˆå°å†™ï¼Œå®ƒå°±æ˜¯ `Uncapitalize`ï¼š

```typescript
type A = 'HELLO WORLD'
type E = Expect<Equal<Uncapitalize<A>, 'hELLO WORLD'>>
```

å› ä¸ºè¿™ä¸€é¢˜é‡Œé¢é¦–å­—æ¯æ˜¯å¤§å†™æ—¶ï¼Œåªéœ€è¦æŠŠå®ƒè½¬æˆå°å†™å³å¯ï¼Œè€Œä¸éœ€è¦å†åŠ ä¸Š `-`ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¯¹å‰©ä½™å­—ç¬¦è¿›è¡Œåˆ¤æ–­ï¼š

```typescript
type KebabCase<S> = S extends `${infer F}${infer R}`
  ? R extends Uncapitalize<R>
    ? `${Lowercase<F>}${KebabCase<R>}`
    : `${Lowercase<F>}-${KebabCase<R>}`
  : S
```

### Diff

> Get an `Object` that is the difference between `O` & `O1`

```typescript
type Diff<O, O1> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type Foo = {
  name: string
  age: string
}
type Bar = {
  name: string
  age: string
  gender: number
}
type Coo = {
  name: string
  gender: number
}

type cases = [
  Expect<Equal<Diff<Foo, Bar>, { gender: number }>>,
  Expect<Equal<Diff<Bar, Foo>, { gender: number }>>,
  Expect<Equal<Diff<Foo, Coo>, { age: string; gender: number }>>,
  Expect<Equal<Diff<Coo, Foo>, { age: string; gender: number }>>,
]
```

å–å·®é›†ï¼ŒåŸºæ“ï¼Œåªéœ€è¦å»é™¤äº¤é›†å³å¯ï¼š

```typescript
type Diff<O, O1> = {
  [P in Exclude<keyof O, keyof O1> | Exclude<keyof O1, keyof O>]: P extends keyof O
    ? O[P]
    : P extends keyof O1
      ? O1[P]
      : never
}
```

### AnyOf

> Implement Python liked `any` function in the type system. A type takes the Array and returns `true` if any element of the Array is true. If the Array is empty, return `false`.

```typescript
type AnyOf<T extends readonly any[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<AnyOf<[1, 'test', true, [1], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[1, '', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, 'test', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', true, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [1], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], {}]>, false>>,
  Expect<Equal<AnyOf<[]>, false>>,
]
```

åªè¦ä¼ å…¥çš„æ•°ç»„ä¸­æœ‰ä¸€é¡¹ä¸º trueï¼Œåˆ™ç»“æœä¸º trueã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦çŸ¥é“å“ªäº›å€¼æ˜¯ falsy å€¼ï¼Œä» cases ä¸­å¯ä»¥å¾—çŸ¥ï¼š

```typescript
type Falsy = 0 | '' | [] | false | Record<PropertyKey, never>
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç©ºå¯¹è±¡ç±»å‹å¾—é‡‡ç”¨ `Record<PropertyKey, never>` æ¥è¡¨ç¤ºã€‚å¦‚æ­¤ä¸€æ¥ï¼Œè§£é¢˜ä¹Ÿå˜å¾—éå¸¸ç®€å•äº†ï¼š

```typescript
type Falsy = 0 | '' | [] | false | Record<PropertyKey, never>

type AnyOf<T extends readonly any[]> = T[number] extends Falsy
  ? false
  : true
```

### IsNever

> Implement a type IsNever, which takes input type `T`.
>
> If the type of resolves to `never`, return `true`, otherwise `false`.

```typescript
type IsNever<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsNever<never>, true>>,
  Expect<Equal<IsNever<never | string>, false>>,
  Expect<Equal<IsNever<''>, false>>,
  Expect<Equal<IsNever<undefined>, false>>,
  Expect<Equal<IsNever<null>, false>>,
  Expect<Equal<IsNever<[]>, false>>,
  Expect<Equal<IsNever<{}>, false>>,
]
```

æˆ‘æ€»æ„Ÿè§‰è¿™é¢˜ä¸åº”è¯¥å‡ºç°åœ¨è¿™ä¸ªæ ç›®ï¼š

```typescript
type IsNever<T> = [T] extends [never] ? true : false
```

### IsUnion

> Implement a type `IsUnion`, which takes an input type `T` and returns whether `T` resolves to a union type.

```typescript
type IsUnion<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsUnion<string>, false>>,
  Expect<Equal<IsUnion<string | number>, true>>,
  Expect<Equal<IsUnion<'a' | 'b' | 'c' | 'd'>, true>>,
  Expect<Equal<IsUnion<undefined | null | void | ''>, true>>,
  Expect<Equal<IsUnion<{ a: string } | { a: number }>, true>>,
  Expect<Equal<IsUnion<{ a: string | number }>, false>>,
  Expect<Equal<IsUnion<[string | number]>, false>>,
  // Cases where T resolves to a non-union type.
  Expect<Equal<IsUnion<string | never>, false>>,
  Expect<Equal<IsUnion<string | unknown>, false>>,
  Expect<Equal<IsUnion<string | any>, false>>,
  Expect<Equal<IsUnion<string | 'a'>, false>>,
  Expect<Equal<IsUnion<never>, false>>,
]
```

é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆè¦æŠŠ never æ’é™¤æ‰ï¼š

```typescript
type IsUnion<T, A = T> = [T] extends [never]
  ? false
	: // ...
```

å¦‚æœä¼ å…¥çš„æ˜¯è”åˆç±»å‹ï¼Œé‚£ä¹ˆå°±æ‹¿ç¬¬ä¸€é¡¹å’Œæ•´ä¸ªè”åˆç±»å‹è¿›è¡Œå¯¹æ¯”ï¼š

```typescript
type IsUnion<T, A = T> = [T] extends [never]
  ? false
  : T extends A
		? // ...
    : // ...
```

å¦‚æœ T æ˜¯ä¸€ä¸ªéè”åˆç±»å‹ï¼Œé‚£ä¹ˆ `T extends A` è¿™æ¡è¯­å¥æ°¸è¿œéƒ½ä¼šæ˜¯ trueï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦è¿›ä¸€æ­¥åˆ¤æ–­ï¼Œé€šè¿‡ä¸€ä¸ªå°æŠ€å·§ï¼š

```typescript
type IsUnion<T, A = T> = [T] extends [never]
  ? false
  : T extends A
    ? Equal<[T], [A]> extends true
      ? false
      : true
    : false
```

å¦‚æœ T æ˜¯ä¸€ä¸ªè”åˆç±»å‹ï¼Œå‡è®¾æ˜¯ï¼š`string | number`ï¼Œé‚£ä¹ˆ `[T]` å°±æ˜¯ `[string]`ï¼Œè€Œ `[A]` å°±æ˜¯ `[string | number]` ï¼Œå®ƒä»¬ä¸¤è€…å¿…ä¸ç›¸ç­‰ï¼›å¦‚æœ T æ˜¯ä¸€ä¸ªéè”åˆç±»å‹ï¼Œå‡è®¾æ˜¯ï¼š`string`ï¼Œé‚£ä¹ˆ `[T]` å’Œ `[A]` éƒ½æ˜¯ `[string]`ï¼Œä¸¤è€…ç›¸ç­‰ã€‚æ‰€ä»¥ä»¥æ­¤æ¥åˆ¤æ–­å®ƒæ˜¯å¦ä¸ºä¸€ä¸ªè”åˆç±»å‹ã€‚

### ReplaceKeys

> Implement a type ReplaceKeys, that replace keys in union types, if some type has not this key, just skip replacing,
>
>  A type takes three arguments.

```typescript
type ReplaceKeys<U, T, Y> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type NodeA = {
  type: 'A'
  name: string
  flag: number
}

type NodeB = {
  type: 'B'
  id: number
  flag: number
}

type NodeC = {
  type: 'C'
  name: string
  flag: number
}

type ReplacedNodeA = {
  type: 'A'
  name: number
  flag: string
}

type ReplacedNodeB = {
  type: 'B'
  id: number
  flag: string
}

type ReplacedNodeC = {
  type: 'C'
  name: number
  flag: string
}

type NoNameNodeA = {
  type: 'A'
  flag: number
  name: never
}

type NoNameNodeC = {
  type: 'C'
  flag: number
  name: never
}

type Nodes = NodeA | NodeB | NodeC
type ReplacedNodes = ReplacedNodeA | ReplacedNodeB | ReplacedNodeC
type NodesNoName = NoNameNodeA | NoNameNodeC | NodeB

type cases = [
  Expect<Equal<ReplaceKeys<Nodes, 'name' | 'flag', { name: number; flag: string }>, ReplacedNodes>>,
  Expect<Equal<ReplaceKeys<Nodes, 'name', { aa: number }>, NodesNoName>>,
]
```

é¢˜ç›®ä¸­æŒ‡å‡ºéœ€è¦ä¸‰ä¸ªæ³›å‹å‚æ•°ï¼Œåˆ†åˆ«æ˜¯ï¼šæºç±»å‹ï¼ˆUï¼‰ã€éœ€è¦çš„é”®ï¼ˆTï¼‰ä»¥åŠæ›¿æ¢é”®ç»„æˆçš„æ¥å£ï¼ˆYï¼‰ï¼Œè€Œæˆ‘ä»¬è¦åšçš„æ˜¯ï¼ŒæŠŠ U ä¸­æ‰€æœ‰ç¬¦åˆ T çš„é”®éƒ½æ›¿æ¢æˆ Y é‡Œé¢çš„ç±»å‹ã€‚

æ‰€ä»¥è§£é¢˜çš„æ–¹æ³•ä¹Ÿå¾ˆç®€å•äº†ï¼ŒæŠŠéœ€è¦åŒ¹é…çš„æ¡ä»¶éƒ½åˆ—å‡ºæ¥å³å¯ï¼š

```typescript
type ReplaceKeys<U, T, Y> = {
  [P in keyof U]: P extends T
    ? P extends keyof Y
      ? Y[P]
      : never
    : U[P]
}
```

### Remove Index Signature

> Implement `RemoveIndexSignature<T>` , exclude the index signature from object types.

```typescript
type RemoveIndexSignature<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type Foo = {
  [key: string]: any
  foo(): void
}

type Bar = {
  [key: number]: any
  bar(): void
  0: string
}

const foobar = Symbol('foobar')
type FooBar = {
  [key: symbol]: any
  [foobar](): void
}

type Baz = {
  bar(): void
  baz: string
}

type cases = [
  Expect<Equal<RemoveIndexSignature<Foo>, { foo(): void }>>,
  Expect<Equal<RemoveIndexSignature<Bar>, { bar(): void; 0: string }>>,
  Expect<Equal<RemoveIndexSignature<FooBar>, { [foobar](): void }>>,
  Expect<Equal<RemoveIndexSignature<Baz>, { bar(): void; baz: string }>>,
]
```

ä»å¯¹è±¡ä¸­ç§»é™¤ç´¢å¼•ç±»å‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å…ˆéœ€è¦åˆ¤æ–­å“ªäº›æ‰æ˜¯ç´¢å¼•ç±»å‹ï¼š

```typescript
type IsSignature<T> = string extends T
  ? true
  : number extends T
    ? true
    : symbol extends T
      ? true
      : false
```

ä»å¯¹è±¡ä¸­åˆ é™¤ä¸€ä¸ªé”®ï¼Œå°†è¯¥é”®ç½®ä¸º never å³å¯ï¼š

```typescript
type Obj = {
  a: string;
  b: number;
}
type DeleteKeys<T> = {
  [K in keyof T as never]: T[K]
}
type EmptyObj = DeleteKeys<Obj> // {}
```

æ‰€ä»¥æœ€ç»ˆç­”æ¡ˆå¦‚ä¸‹ä»£ç æ‰€ç¤ºï¼š

```typescript
type IsSignature<T> = string extends T
  ? true
  : number extends T
    ? true
    : symbol extends T
      ? true
      : false

type RemoveIndexSignature<T> = {
  [P in keyof T as IsSignature<P> extends true ? never : P]: T[P]
}
```

### Percentage Parser

> Implement PercentageParser<T extends string>.
>
>  According to the `/^(\+|\-)?(\d*)?(\%)?$/` regularity to match T and get three matches.

```typescript
type PercentageParser<A extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type Case0 = ['', '', '']
type Case1 = ['+', '', '']
type Case2 = ['+', '1', '']
type Case3 = ['+', '100', '']
type Case4 = ['+', '100', '%']
type Case5 = ['', '100', '%']
type Case6 = ['-', '100', '%']
type Case7 = ['-', '100', '']
type Case8 = ['-', '1', '']
type Case9 = ['', '', '%']
type Case10 = ['', '1', '']
type Case11 = ['', '100', '']

type cases = [
  Expect<Equal<PercentageParser<''>, Case0>>,
  Expect<Equal<PercentageParser<'+'>, Case1>>,
  Expect<Equal<PercentageParser<'+1'>, Case2>>,
  Expect<Equal<PercentageParser<'+100'>, Case3>>,
  Expect<Equal<PercentageParser<'+100%'>, Case4>>,
  Expect<Equal<PercentageParser<'100%'>, Case5>>,
  Expect<Equal<PercentageParser<'-100%'>, Case6>>,
  Expect<Equal<PercentageParser<'-100'>, Case7>>,
  Expect<Equal<PercentageParser<'-1'>, Case8>>,
  Expect<Equal<PercentageParser<'%'>, Case9>>,
  Expect<Equal<PercentageParser<'1'>, Case10>>,
  Expect<Equal<PercentageParser<'100'>, Case11>>,
]
```

è¿™é¢˜å¯ä»¥åˆ†ä¸¤æ­¥æ¥åˆ¤æ–­ï¼Œä¸€ä¸ªæ˜¯ä»¥ `'+' | '-'` å¼€å¤´ï¼Œå¦ä¸€ä¸ªæ˜¯ä»¥ `'%'` ç»“æŸï¼š

```typescript
type PercentageParser<A extends string> = A extends `${infer S extends '+' | '-'}${infer R}`
  ? R extends `${infer F}%`
    ? [S, F, '%']
    : [S, R, '']
  : A extends `${infer F}%`
    ? ['', F, '%']
    : ['', A, '']
```

### Drop Char

> Drop a specified char from a string.

```typescript
type DropChar<S, C> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  // @ts-expect-error
  Expect<Equal<DropChar<'butter fly!', ''>, 'butterfly!'>>,
  Expect<Equal<DropChar<'butter fly!', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<'butter fly!', '!'>, 'butter fly'>>,
  Expect<Equal<DropChar<'    butter fly!        ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', 'b'>, '  u t t e r f l y ! '>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', 't'>, ' b u   e r f l y ! '>>,
]
```

åˆæ˜¯ä¸€é“å­—ç¬¦ä¸²æ“ä½œé¢˜ï¼Œé€’å½’å¤„ç†å³å¯ï¼š

```typescript
type DropChar<S, C, Result extends string = ''> = S extends `${infer F}${infer R}`
  ? F extends C
    ? DropChar<R, C, Result>
    : DropChar<R, C, `${Result}${F}`>
  : Result
```

æˆ–è€…ï¼š

```typescript
type DropChar<S extends string, C extends string> = S extends `${infer F}${infer R}`
  ? `${F extends C ? '' : F}${DropChar<R, C>}`
  : S
```

è¿™é¢˜çš„ `// @ts-expect-error` æœ‰ç‚¹è°œï¼Œå°±ä¸å¤„ç†äº†ã€‚

### MinusOne

> Given a number (always positive) as a type. Your type should return the number decreased by one.

```typescript
type MinusOne<T extends number> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MinusOne<1>, 0>>,
  Expect<Equal<MinusOne<55>, 54>>,
  Expect<Equal<MinusOne<3>, 2>>,
  Expect<Equal<MinusOne<100>, 99>>,
  Expect<Equal<MinusOne<1101>, 1100>>,
]
```

æ•°ç»„å®ƒæ‰¿å—äº†å®ƒä¸è¯¥æ‰¿å—çš„ä¸œè¥¿ï¼Œåªå› ä¸ºå®ƒæœ‰ä¸ª `length`ï¼Œæ‰€ä»¥åœ¨åšè¿™ç§åŠ å‡æ³•çš„ç±»å‹ä½“æ“ï¼Œæˆ‘ä»¬åªéœ€è¦ç»™ä¸ªæ•°ç»„ï¼Œæœ€ç»ˆæ‹¿åˆ°å®ƒçš„ Length å³å¯ï¼š

```typescript
type Fill<N extends number, R extends number[] = []> = R['length'] extends N
  ? R
  : Fill<N, [...R, 0]>

type MinusOne<T extends number, A extends number[] = []> = Fill<T> extends [infer F, ...infer R]
  ? R['length']
  : never
```

ä½†è¿™ä¸€é¢˜ï¼Œéœ€è¦æ³¨æ„ä¸€ä¸‹é€’å½’æº¢å‡ºé—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨å…¶ä»–åŠæ³•æ¥åˆ›å»ºä¸€ä¸ªç¬¦åˆé¢˜ç›®è¦æ±‚çš„æ•°ç»„ï¼š

```typescript
type Dict = {
  '0': [];
  '1': [0];
  '2': [0, 0];
  '3': [0, 0, 0];
  '4': [0, 0, 0, 0];
  '5': [0, 0, 0, 0, 0];
  '6': [0, 0, 0, 0, 0, 0];
  '7': [0, 0, 0, 0, 0, 0, 0];
  '8': [0, 0, 0, 0, 0, 0, 0, 0];
  '9': [0, 0, 0, 0, 0, 0, 0, 0, 0];
}

type FillTenTimes<A extends 0[] = []> = [
  ...A, ...A, ...A, ...A, ...A,
  ...A, ...A, ...A, ...A, ...A
]

type Fill<N extends string, Result extends 0[] = []> = N extends `${infer F extends keyof Dict}${infer R}`
  ? Fill<R, [...FillTenTimes<Result>, ...Dict[F]]>
  : Result

type MinusOne<T extends number> = Fill<`${T}`> extends [infer F, ...infer R]
  ? R['length']
  : T

```

è¿™é‡Œè§£é‡Šä¸€ä¸‹è¿™ä¸ªæ•°ç»„æ˜¯æ€ä¹ˆè¢«åˆ›å»ºå‡ºæ¥çš„ï¼Œä»¥æœ€åä¸€ä¸ª case çš„ 1101 ä¸ºä¾‹ï¼š

1. äº¤ç»™ `Fill` æ¥å¡«å……çš„æ˜¯å­—ç¬¦ä¸² `1101`ï¼Œæ­¤æ—¶ `F === '1'`ï¼Œ`R === '101'`ï¼Œåˆå§‹çš„ `Result` ä¸º `[]`ï¼Œå®ƒç»è¿‡ `FillTenTimes` å¤„ç†åè¿˜æ˜¯ `[]`ï¼Œ`Dict[F]` ä¸º `[0]`ï¼Œæ‰€ä»¥äº¤ç»™ç¬¬äºŒæ¬¡é€’å½’çš„æ˜¯ `Fill<'101', [0]>`ï¼›
2. ç¬¬äºŒæ¬¡é€’å½’æ—¶ï¼š`F === '1'`ï¼Œ`R === '01'`ï¼Œ`Result === [0]`ï¼Œç„¶å Result ç»è¿‡ `FillTenTimes` å¤„ç†åå˜æˆ `[10 * 0]`ï¼Œ`Dict[F]` ä¸º `[0]`ï¼Œæ‰€ä»¥äº¤ç»™ç¬¬ä¸‰æ¬¡é€’å½’çš„æ˜¯ `Fill<'01', [10 * 0, 0]>`ï¼›
3. ç¬¬ä¸‰æ¬¡é€’å½’æ—¶ï¼š`F === '0'`ï¼Œ`R === '1'`ï¼Œ`Result === [11 * 0]`ï¼Œ ç„¶å Result ç»è¿‡ `FillTenTimes` å¤„ç†åå˜æˆ `[110 * 0]`ï¼Œ`Dict[F]` ä¸º `[]`ï¼Œæ‰€ä»¥äº¤ç»™ç¬¬å››æ¬¡é€’å½’çš„æ˜¯ `Fill<'1', [110 * 0]>`ï¼›
4. ç¬¬å››æ¬¡é€’å½’æ—¶ï¼š`F === '1'`ï¼Œ`R === ''`ï¼Œ`Result === [110 * 0]`ï¼Œç„¶å Result ç»è¿‡ `FillTenTimes` å¤„ç†åå˜æˆ `[1100 * 0]`ï¼Œ`Dict[f]` ä¸º `[0]`ï¼Œæ‰€ä»¥äº¤ç»™ç¬¬äº”æ¬¡é€’å½’çš„æ˜¯ `Fill<'', [1100 * 0, 0]>`ï¼›
5. ç¬¬äº”æ¬¡é€’å½’æ—¶ï¼Œç”±äºä¼ å…¥çš„æ˜¯ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼Œæ‰€ä»¥æ¡ä»¶ä¸æ»¡è¶³ï¼Œæ­¤æ—¶è¿”å› Resultï¼Œä¹Ÿå°±æ˜¯ `[1101 * 1]`ã€‚

### PickByType

> From `T`, pick a set of properties whose type are assignable to `U`.

```typescript
type PickByType<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

interface Model {
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}

type cases = [
  Expect<Equal<PickByType<Model, boolean>, { isReadonly: boolean; isEnable: boolean }>>,
  Expect<Equal<PickByType<Model, string>, { name: string }>>,
  Expect<Equal<PickByType<Model, number>, { count: number }>>,
]
```

å’Œ Pick å¾ˆç±»ä¼¼ï¼Œåªä¸è¿‡æ˜¯éœ€è¦åˆ¤æ–­çš„æ˜¯å€¼ï¼š

```typescript
type PickByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P]
}
```

### StartsWith

> Implement `StartsWith<T, U>` which takes two exact string types and returns whether `T` starts with `U`

```typescript
type StartsWith<T extends string, U extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<StartsWith<'abc', 'ac'>, false>>,
  Expect<Equal<StartsWith<'abc', 'ab'>, true>>,
  Expect<Equal<StartsWith<'abc', 'abcd'>, false>>,
  Expect<Equal<StartsWith<'abc', ''>, true>>,
  Expect<Equal<StartsWith<'abc', ' '>, false>>,
]
```

åˆæ˜¯ä¸€é“è€ƒéªŒå­—ç¬¦ä¸²æ“ä½œçš„é¢˜ï¼š

```typescript
type StartsWith<T extends string, U extends string> = T extends `${U}${infer R}`
  ? true
  : false
```

### EndsWith

> Implement `EndsWith<T, U>` which takes two exact string types and returns whether `T` ends with `U`

```typescript
type EndsWith<T extends string, U extends string> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<EndsWith<'abc', 'bc'>, true>>,
  Expect<Equal<EndsWith<'abc', 'abc'>, true>>,
  Expect<Equal<EndsWith<'abc', 'd'>, false>>,
]
```

å’Œ StartsWith ä¸€æ ·ï¼Œåªéœ€è¦å˜æ¢ä¸€ä¸‹ä½ç½®ï¼š

```typescript
type EndsWith<T extends string, U extends string> = T extends `${infer R}${U}`
  ? true
  : false
```

### PartialByKeys

> Implement a generic `PartialByKeys<T, K>` which takes two type argument `T` and `K`.

```typescript
type PartialByKeys<T, K> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

interface User {
  name: string
  age: number
  address: string
}

interface UserPartialName {
  name?: string
  age: number
  address: string
}

interface UserPartialNameAndAge {
  name?: string
  age?: number
  address: string
}

type cases = [
  Expect<Equal<PartialByKeys<User, 'name'>, UserPartialName>>,
  Expect<Equal<PartialByKeys<User, 'name' | 'unknown'>, UserPartialName>>,
  Expect<Equal<PartialByKeys<User, 'name' | 'age'>, UserPartialNameAndAge>>,
  Expect<Equal<PartialByKeys<User>, Partial<User>>>,
]
```

å°†ç¬¦åˆæŒ‡å®šçš„ Key çš„é‚£äº›é¡¹è½¬æˆå¯é€‰é¡¹ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†æˆä¸¤æ­¥æ¥åšï¼šä¸€æ˜¯ä»æºå¯¹è±¡ä¸­ç§»é™¤æŒ‡å®šçš„ Keyï¼ˆ[Omit](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys)ï¼‰ï¼›äºŒæ˜¯ä»æºå¯¹è±¡ä¸­å–å‡ºæŒ‡å®šçš„ Key ï¼ˆ[Extract](https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union)ï¼‰å¹¶å°†å®ƒä»¬è½¬æˆå¯é€‰çš„ï¼š

```typescript
// 1. é€šè¿‡ Omit ç§»é™¤æŒ‡å®šçš„ Key
type RequiredObject<T, K extends PropertyKey = keyof T> = Omit<T, K>
// 2. é€šè¿‡ Extract è¿‡æ»¤æŒ‡å®šçš„ Key
type PatrialObject<T, K extends PropertyKey = keyof T> = {
  [P in Extract<K, keyof T>]?: T[P]
}
```

ç„¶åå†å°†ä¸¤è€…åˆå¹¶å³å¯ï¼š

```typescript
type Merge<T> = Omit<T, never>

type PartialByKeys<T, K extends PropertyKey = keyof T> = Merge<Omit<T, K> & {
  [P in Extract<K, keyof T>]?: T[P]
}>
```

### RequiredByKeys

> Implement a generic `RequiredByKeys<T,  K>` which takes two type argument `T` and `K`.
>
> `K` specify the set of properties of `T` that should set to be required. When `K` is not provided, it should make all properties required just like the normal `Required<T>`.

```typescript
type RequiredByKeys<T, K> = any


/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

interface User {
  name?: string
  age?: number
  address?: string
}

interface UserRequiredName {
  name: string
  age?: number
  address?: string
}

interface UserRequiredNameAndAge {
  name: string
  age: number
  address?: string
}

type cases = [
  Expect<Equal<RequiredByKeys<User, 'name'>, UserRequiredName>>,
  Expect<Equal<RequiredByKeys<User, 'name' | 'unknown'>, UserRequiredName>>,
  Expect<Equal<RequiredByKeys<User, 'name' | 'age'>, UserRequiredNameAndAge>>,
  Expect<Equal<RequiredByKeys<User>, Required<User>>>,
]
```

è¿™é¢˜çš„æ€è·¯å’Œ [PartialByKeys](#PartialByKeys) ä¸€æ ·ï¼Œä½†æœ‰ç‚¹å°åŒºåˆ«ï¼š

```typescript
type Merge<T> = Omit<T, never>

type RequiredByKeys<T, K = keyof T> = Merge<{
  [P in keyof T as P extends K ? P : never]-?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}>
```

### Mutable

> Implement the generic ```Mutable<T>``` which makes all properties in ```T``` mutable (not readonly).

```typescript
type Mutable<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

interface Todo1 {
  title: string
  description: string
  completed: boolean
  meta: {
    author: string
  }
}

type List = [1, 2, 3]

type cases = [
  Expect<Equal<Mutable<Readonly<Todo1>>, Todo1>>,
  Expect<Equal<Mutable<Readonly<List>>, List>>,
]

type errors = [
  // @ts-expect-error
  Mutable<'string'>,
  // @ts-expect-error
  Mutable<0>,
]
```

é€šè¿‡ `-` å·æ“ä½œå¯ä»¥æŠŠ readonly æ ‡è¯†ç»™ç§»é™¤ï¼ŒåŒæ—¶åˆ«å¿˜äº†ç»™æ³›å‹åŠ çº¦æŸå¤„ç†æ‰ errorsï¼š

```typescript
type Mutable<T extends Record<PropertyKey, any>> = {
  -readonly [P in keyof T]: T[P]
}
```

### OmitByType

> From ```T```, pick a set of properties whose type are not assignable to ```U```.

```typescript
type OmitByType<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

interface Model {
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}

type cases = [
  Expect<Equal<OmitByType<Model, boolean>, { name: string; count: number }>>,
  Expect<Equal<OmitByType<Model, string>, { count: number; isReadonly: boolean; isEnable: boolean }>>,
  Expect<Equal<OmitByType<Model, number>, { name: string; isReadonly: boolean; isEnable: boolean }>>,
]
```

åªéœ€è¦æŠŠå€¼çš„ç±»å‹åšä¸€æ¬¡å¯¹æ¯”å³å¯ï¼š

```typescript
type OmitByType<T, U> = {
  [P in keyof T as T[P] extends U ? never : P]: T[P]
}
```

### ObjectEntries

> Implement the type version of ```Object.entries```

```typescript
type ObjectEntries<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

interface Model {
  name: string
  age: number
  locations: string[] | null
}

type ModelEntries = ['name', string] | ['age', number] | ['locations', string[] | null]

type cases = [
  Expect<Equal<ObjectEntries<Model>, ModelEntries>>,
  Expect<Equal<ObjectEntries<Partial<Model>>, ModelEntries>>,
  Expect<Equal<ObjectEntries<{ key?: undefined }>, ['key', undefined]>>,
  Expect<Equal<ObjectEntries<{ key: undefined }>, ['key', undefined]>>,
]
```

è¿™é¢˜éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼Œä¸€ä¸ªæ˜¯æŠŠ T è½¬æˆ Requiredï¼Œå¦ä¸€ä¸ªå°±æ˜¯ undefined çš„å¤„ç†ï¼š

```typescript
type ObjectEntries<T, R = Required<T>, K extends keyof R = keyof R> = K extends keyof R
  ? [K, R[K] extends undefined ? undefined : R[K]]
  : never
```

### Shift

> Implement the type version of ```Array.shift```

```typescript
type Shift<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Shift<[3, 2, 1]>, [2, 1]>>,
  Expect<Equal<Shift<['a', 'b', 'c', 'd']>, ['b', 'c', 'd']>>,
]
```

è¿™é¢˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼š

```typescript
type Shift<T> = T extends [infer F, ...infer R]
  ? R
  : never
```

### Tuple to Nested Object

> Given a tuple type ```T``` that only contains string type, and a type ```U```, build an object recursively.

```typescript
type TupleToNestedObject<T, U> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TupleToNestedObject<['a'], string>, { a: string }>>,
  Expect<Equal<TupleToNestedObject<['a', 'b'], number>, { a: { b: number } }>>,
  Expect<Equal<TupleToNestedObject<['a', 'b', 'c'], boolean>, { a: { b: { c: boolean } } }>>,
  Expect<Equal<TupleToNestedObject<[], boolean>, boolean>>,
]
```

å¸¸è§„çš„æ•°ç»„é€’å½’æ“ä½œå³å¯ï¼š

```typescript
type TupleToNestedObject<T, U> = T extends [infer F extends string, ...infer R]
  ? {
    [P in F]: TupleToNestedObject<R, U>
  }
  : U
```

### Reverse

> Implement the type version of ```Array.reverse```

```typescript
type Reverse<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Reverse<[]>, []>>,
  Expect<Equal<Reverse<['a', 'b']>, ['b', 'a']>>,
  Expect<Equal<Reverse<['a', 'b', 'c']>, ['c', 'b', 'a']>>,
]
```

åè½¬æ•°ç»„ï¼Œè¿™ä¸ªä¹Ÿå¾ˆç®€å•ï¼š

```typescript
type Reverse<T> = T extends [...infer R, infer L]
  ? [L, ...Reverse<R>]
  : T
```

### Flip Arguments

> Implement the type version of lodash's ```_.flip```.
>
>  Type ```FlipArguments<T>``` requires function type ```T``` and returns a new function type which has the same return type of T but reversed parameters.

```typescript
type FlipArguments<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FlipArguments<() => boolean>, () => boolean>>,
  Expect<Equal<FlipArguments<(foo: string) => number>, (foo: string) => number>>,
  Expect<Equal<FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void>, (arg0: boolean, arg1: number, arg2: string) => void>>,
]

type errors = [
  // @ts-expect-error
  FlipArguments<'string'>,
  // @ts-expect-error
  FlipArguments<{ key: 'value' }>,
  // @ts-expect-error
  FlipArguments<['apple', 'banana', 100, { a: 1 }]>,
  // @ts-expect-error
  FlipArguments<null | undefined>,
]
```

é¦–å…ˆéœ€è¦å¯¹æ³›å‹åŠ ä¸Šçº¦æŸè§£å†³ error casesï¼š

```typescript
type FlipArguments<T extends (...args: any[]) => any> = any
```

åè½¬å‚æ•°ï¼Œè¿™å°±å’Œåè½¬æ•°ç»„æ˜¯ä¸€è‡´çš„äº†ï¼š

```typescript
type Reverse<T> = T extends [...infer R, infer L]
  ? [L, ...Reverse<R>]
  : T

type FlipArguments<T extends (...args: any[]) => any> = T extends (...args: infer Args) => infer R
  ? (...args: Reverse<Args>) => R
  : never
```

### FlattenDepth

> Recursively flatten array up to depth times.

```typescript
type FlattenDepth = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FlattenDepth<[]>, []>>,
  Expect<Equal<FlattenDepth<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<FlattenDepth<[1, [2]]>, [1, 2]>>,
  Expect<Equal<FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2>, [1, 2, 3, 4, [5]]>>,
  Expect<Equal<FlattenDepth<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, [[5]]]>>,
  Expect<Equal<FlattenDepth<[1, [2, [3, [4, [5]]]]], 3>, [1, 2, 3, 4, [5]]>>,
  Expect<Equal<FlattenDepth<[1, [2, [3, [4, [5]]]]], 19260817>, [1, 2, 3, 4, 5]>>,
]
```

è¿™é¢˜ç»™çš„åˆå§‹å†…å®¹æœ‰ç‚¹å°‘å¾—å¯æ€œï¼Œæ‰€ä»¥æ³›å‹è¿™ä¸€å—å°±éœ€è¦æˆ‘ä»¬è‡ªå·±è¡¥å……ä¸Šå»äº†ï¼š

```typescript
type FlattenDepth<T extends unknown[], D extends number = 1> = any
```

éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œçš„ case æœ‰ä¸€ä¸ªæ¯”è¾ƒå¤§çš„å±‚çº§æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½å¤Ÿé‡‡ç”¨å‡æ³•çš„å½¢å¼æ¥è®¡ç®—ï¼Œå†å€ŸåŠ©ä¸€ä¸ªåˆå§‹å€¼åšåŠ æ³•æ¯”å¯¹ï¼š

```typescript
type FlattenDepth<T extends unknown[], D extends number = 1, S extends number = 0>
```

è§£é¢˜æ€è·¯å°±æ¯”è¾ƒç®€å•äº†ï¼š

```typescript
type Plus<T extends number, R extends 0[] = []> = R['length'] extends T
  ? [...R, 0]['length']
  : Plus<T, [0, ...R]>

type FlattenDepth<T extends unknown[], D extends number = 1, S extends number = 0> = S extends D
  ? T
  : T extends [infer F, ...infer R]
    ? [
      ...(F extends any[]
        ? FlattenDepth<F, D, Plus<S>>
        : [F]
      ),
      ...FlattenDepth<R, D, S>
    ]
    : T
```

### BEM style string

> The Block, Element, Modifier methodology (BEM) is a popular naming convention for classes in CSS. 
>
> For example, the block component would be represented as `btn`, element that depends upon the block would be represented as `btn__price`, modifier that changes the style of the block would be represented as `btn--big` or `btn__price--warning`.
>
>  Implement `BEM<B, E, M>` which generate string union from these three parameters. Where `B` is a string literal, `E` and `M` are string arrays (can be empty).

```typescript
type BEM<B extends string, E extends string[], M extends string[]> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<BEM<'btn', ['price'], []>, 'btn__price'>>,
  Expect<Equal<BEM<'btn', ['price'], ['warning', 'success']>, 'btn__price--warning' | 'btn__price--success' >>,
  Expect<Equal<BEM<'btn', [], ['small', 'medium', 'large']>, 'btn--small' | 'btn--medium' | 'btn--large' >>,
]
```

è¿™é¢˜æˆ‘ä»¬éœ€è¦åˆ©ç”¨ `T[number]` å°†æ•°ç»„è½¬æˆ Unionï¼š

```typescript
type BEM<B extends string, E extends string[], M extends string[]> = `${B}${E[number] extends '' ? '' : `__${E[number]}`}${M[number] extends '' ? '' : `--${M[number]}`}`
```

### InorderTraversal

> Implement the type version of binary tree inorder traversal.

```typescript
interface TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
}
type InorderTraversal<T extends TreeNode | null> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

const tree1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null,
    },
    right: null,
  },
} as const

const tree2 = {
  val: 1,
  left: null,
  right: null,
} as const

const tree3 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null,
  },
  right: null,
} as const

const tree4 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: null,
    right: null,
  },
} as const

type cases = [
  Expect<Equal<InorderTraversal<null>, []>>,
  Expect<Equal<InorderTraversal<typeof tree1>, [1, 3, 2]>>,
  Expect<Equal<InorderTraversal<typeof tree2>, [1]>>,
  Expect<Equal<InorderTraversal<typeof tree3>, [2, 1]>>,
  Expect<Equal<InorderTraversal<typeof tree4>, [1, 2]>>,
]
```

è¿™é¢˜æˆ‘ä»¬éœ€è¦æ³¨æ„çš„æ˜¯å®ƒçš„å–å€¼é¡ºåºæ˜¯ `left.val` ã€`val`ã€`right.val`ï¼š

```typescript
type InorderTraversal<T extends TreeNode | null> = T extends TreeNode
  ? [
      ...T['left'] extends TreeNode ? InorderTraversal<T['left']> : [],
      T['val'],
      ...T['right'] extends TreeNode ? InorderTraversal<T['right']> : []
    ]
  : []
```

### Flip

> Implement the type of `just-flip-object`.

```typescript
type Flip<T> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect, NotEqual } from '@type-challenges/utils'

type cases = [
  Expect<Equal<{ a: 'pi' }, Flip<{ pi: 'a' }>>>,
  Expect<NotEqual<{ b: 'pi' }, Flip<{ pi: 'a' }>>>,
  Expect<Equal<{ 3.14: 'pi'; true: 'bool' }, Flip<{ pi: 3.14; bool: true }>>>,
  Expect<Equal<{ val2: 'prop2'; val: 'prop' }, Flip<{ prop: 'val'; prop2: 'val2' }>>>,
]
```

è¿™é¢˜æ˜¯æŠŠé”®å€¼äº¤æ¢ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹è±¡çš„é”®ä¹Ÿå°±æ˜¯ `PropertyKey` ä»–åªèƒ½æ˜¯ `string | number | symbol` ï¼Œå¦‚æœä¸ç¬¦åˆ `PropertyKey` çš„çº¦æŸï¼Œæˆ‘ä»¬éœ€è¦æŠŠå®ƒè½¬æˆå­—ç¬¦ä¸²ï¼š

```typescript
type Flip<T extends Record<PropertyKey, any>> = {
  [P in keyof T as T[P] extends PropertyKey ? T[P] : `${T[P]}`]: P
}
```

### Fibonacci Sequence

> Implement a generic Fibonacci\<T\> takes an number T and returns it's corresponding [Fibonacci number](https://en.wikipedia.org/wiki/Fibonacci_number).

```typescript
type Fibonacci<T extends number> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Fibonacci<3>, 2>>,
  Expect<Equal<Fibonacci<8>, 21>>,
]
```

æˆ‘ä»¬éœ€è¦äº†è§£ä»€ä¹ˆæ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼š`1, 1, 2, 3, 5, 8, 13, ...`

ç„¶åä»ä¸­å–å‡ºæŒ‡å®šç´¢å¼•çš„å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€äº›è¾…åŠ©ç±»å‹æ¥å­˜å‚¨ä¸Šä¸€ä¸ªå€¼å’Œå½“å‰å€¼ï¼Œå¹¶ä¸”è®©è®¡ç®—ä»ç¬¬ 2 é¡¹æ‰å¼€å§‹ï¼š

```typescript
type NumberToTuple<T extends Number, R extends 0[] = []> = R['length'] extends T
  ? R
  : NumberToTuple<T, [...R, 0]>

type Plus<T extends number, N extends number> = [
  ...NumberToTuple<T>,
  ...NumberToTuple<N>
]['length'] & number

// 1, 1, 2, 3, 5, 8,  ...

type Fibonacci<
  T extends number,
  Start extends number = 2,
  Prev extends number = 0,
  Last extends number = 1
> = T extends 0 | 1
  ? 1
  : Start extends T
    ? Plus<Prev, Last>
    : Fibonacci<T, Plus<Start, 1>, Last, Plus<Prev, Last>>
```

### AllCombinations

> Implement type ```AllCombinations<S>``` that return all combinations of strings which use characters from ```S``` at most once.

```typescript
type AllCombinations<S> = any

/* _____________ Test Cases _____________ */
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<AllCombinations<''>, ''>>,
  Expect<Equal<AllCombinations<'A'>, '' | 'A'>>,
  Expect<Equal<AllCombinations<'AB'>, '' | 'A' | 'B' | 'AB' | 'BA'>>,
  Expect<Equal<AllCombinations<'ABC'>, '' | 'A' | 'B' | 'C' | 'AB' | 'AC' | 'BA' | 'BC' | 'CA' | 'CB' | 'ABC' | 'ACB' | 'BAC' | 'BCA' | 'CAB' | 'CBA'>>,
  Expect<Equal<AllCombinations<'ABCD'>, '' | 'A' | 'B' | 'C' | 'D' | 'AB' | 'AC' | 'AD' | 'BA' | 'BC' | 'BD' | 'CA' | 'CB' | 'CD' | 'DA' | 'DB' | 'DC' | 'ABC' | 'ABD' | 'ACB' | 'ACD' | 'ADB' | 'ADC' | 'BAC' | 'BAD' | 'BCA' | 'BCD' | 'BDA' | 'BDC' | 'CAB' | 'CAD' | 'CBA' | 'CBD' | 'CDA' | 'CDB' | 'DAB' | 'DAC' | 'DBA' | 'DBC' | 'DCA' | 'DCB' | 'ABCD' | 'ABDC' | 'ACBD' | 'ACDB' | 'ADBC' | 'ADCB' | 'BACD' | 'BADC' | 'BCAD' | 'BCDA' | 'BDAC' | 'BDCA' | 'CABD' | 'CADB' | 'CBAD' | 'CBDA' | 'CDAB' | 'CDBA' | 'DABC' | 'DACB' | 'DBAC' | 'DBCA' | 'DCAB' | 'DCBA'>>,
]
```

é¦–å…ˆè¦åšçš„å°±æ˜¯æŠŠå­—ç¬¦ä¸²ç»™è½¬æˆè”åˆç±»å‹ï¼š

```typescript
type StringToUnion<S extends string = ''> = S extends `${infer F}${infer R}` 
  ? F | StringToUnion<R>
  : never
```

ç„¶ååˆ©ç”¨åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹è‡ªåŠ¨ç”Ÿæˆç»“æœï¼š

```typescript
type StringToUnion<S extends string = ''> = S extends `${infer F}${infer R}`
  ? F | StringToUnion<R>
  : never

type Combinations<T extends string> = [T] extends [never]
  ? ''
  : '' | { [K in T]: `${K}${Combinations<Exclude<T, K>>}` }[T]

type AllCombinations<S extends string> = Combinations<StringToUnion<S>>
```

åˆ†æç»“æœå¯ä»¥çœ‹è¿™é‡Œï¼š[https://www.yuque.com/liaojie3/yuiou5/ogyeiz#giVmO](https://www.yuque.com/liaojie3/yuiou5/ogyeiz#giVmO)

